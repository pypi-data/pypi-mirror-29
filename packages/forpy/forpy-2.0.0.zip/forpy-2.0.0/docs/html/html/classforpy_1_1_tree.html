<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=9"/>
        <meta name="generator" content="Doxygen 1.8.14"/>
        <title>forpy: forpy::Tree Class Reference</title>
        <link href="tabs.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="stylesheet.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div id="titlearea">
                <table cellspacing="0" cellpadding="0">
                    <tbody>
                        <tr style="height: 56px;">
                            <td style="padding-left: 0.5em;">
                                <div id="projectname">forpy
                                    &#160;<span id="projectnumber">2</span>
                                </div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classforpy_1_1_tree.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classforpy_1_1_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">forpy::Tree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main tree class for the forpy framework.  
 <a href="classforpy_1_1_tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tree_8h_source.html">tree.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for forpy::Tree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classforpy_1_1_tree.png" usemap="#forpy::Tree_map" alt=""/>
  <map id="forpy::Tree_map" name="forpy::Tree_map">
<area href="classforpy_1_1_classification_tree.html" alt="forpy::ClassificationTree" shape="rect" coords="0,56,149,80"/>
<area href="classforpy_1_1_regression_tree.html" alt="forpy::RegressionTree" shape="rect" coords="159,56,308,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa48b090a00bb0557146bb3d5fb45f3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#afa48b090a00bb0557146bb3d5fb45f3f">Tree</a> (const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;<a class="el" href="classforpy_1_1_tree.html#ab5f61943c13ee4a49cee80379688bf64">max_depth</a>=std::numeric_limits&lt; <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &gt;::max(), const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;<a class="el" href="classforpy_1_1_tree.html#abbda07d8785ef47b669607621af59d11">min_samples_at_leaf</a>=1, const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;<a class="el" href="classforpy_1_1_tree.html#a65c0a49605a095981066f865a5cddfd5">min_samples_at_node</a>=2, const std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_decider.html">IDecider</a> &gt; &amp;<a class="el" href="classforpy_1_1_tree.html#ab5a6ab26fac8f02143edc7ca86f55c40">decider</a>=nullptr, const std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_leaf.html">ILeaf</a> &gt; &amp;<a class="el" href="classforpy_1_1_tree.html#aaf2020df1c36fe0a935ea9ec2e6355b6">leaf_manager</a>=nullptr, const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;<a class="el" href="classforpy_1_1_tree.html#a6e72e2f34aa0b4cc540c74a66b806e26">random_seed</a>=1)</td></tr>
<tr class="memdesc:afa48b090a00bb0557146bb3d5fb45f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard constructor for the forpy trees.  <a href="#afa48b090a00bb0557146bb3d5fb45f3f">More...</a><br /></td></tr>
<tr class="separator:afa48b090a00bb0557146bb3d5fb45f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e134d460ce946ed75527a84769e26e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ad1e134d460ce946ed75527a84769e26e">Tree</a> (std::string filename)</td></tr>
<tr class="memdesc:ad1e134d460ce946ed75527a84769e26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor for the forpy trees.  <a href="#ad1e134d460ce946ed75527a84769e26e">More...</a><br /></td></tr>
<tr class="separator:ad1e134d460ce946ed75527a84769e26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd94dc0367bea76936d4b577ba55d71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a4fd94dc0367bea76936d4b577ba55d71">make_node</a> (const <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *data_provider, <a class="el" href="structforpy_1_1_desk.html">Desk</a> *d)</td></tr>
<tr class="memdesc:a4fd94dc0367bea76936d4b577ba55d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the creation of one tree node.  <a href="#a4fd94dc0367bea76936d4b577ba55d71">More...</a><br /></td></tr>
<tr class="separator:a4fd94dc0367bea76936d4b577ba55d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e21f03982ebee32e02292b2d0ca2322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a0e21f03982ebee32e02292b2d0ca2322">DFS</a> (const <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *data_provider, const <a class="el" href="namespaceforpy.html#adad607d1828338b79a86c36984d87e82">ECompletionLevel</a> &amp;completion, <a class="el" href="structforpy_1_1_desk.html">Desk</a> *d)</td></tr>
<tr class="memdesc:a0e21f03982ebee32e02292b2d0ca2322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do one DFS step with given completion level.  <a href="#a0e21f03982ebee32e02292b2d0ca2322">More...</a><br /></td></tr>
<tr class="separator:a0e21f03982ebee32e02292b2d0ca2322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b561eb3d6e7328d43e5d09f8e439268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a1b561eb3d6e7328d43e5d09f8e439268">parallel_DFS</a> (<a class="el" href="structforpy_1_1_desk.html">Desk</a> *d, <a class="el" href="structforpy_1_1_todo_mark.html">TodoMark</a> &amp;mark, <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *data_provider, const bool &amp;finalize=true)</td></tr>
<tr class="separator:a1b561eb3d6e7328d43e5d09f8e439268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3387743826c6dbcda481391667e0cd66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a3387743826c6dbcda481391667e0cd66">DFS_and_store</a> (<a class="el" href="structforpy_1_1_desk.html">Desk</a> *d, <a class="el" href="structforpy_1_1_todo_mark.html">TodoMark</a> &amp;mark, const <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *dprov, const <a class="el" href="namespaceforpy.html#adad607d1828338b79a86c36984d87e82">ECompletionLevel</a> &amp;comp)</td></tr>
<tr class="separator:a3387743826c6dbcda481391667e0cd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8177f98112a850f6240e17b275a61a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a1b8177f98112a850f6240e17b275a61a">get_depth</a> () const</td></tr>
<tr class="separator:a1b8177f98112a850f6240e17b275a61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ee73095b840748f6ebbe6d4047bd0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforpy_1_1_tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a18ee73095b840748f6ebbe6d4047bd0e">fit</a> (const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;data_v, const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;annotation_v, const size_t &amp;n_threads, const bool &amp;complete_dfs=true, const std::vector&lt; float &gt; &amp;weights=std::vector&lt; float &gt;())</td></tr>
<tr class="memdesc:a18ee73095b840748f6ebbe6d4047bd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard fitting function.  <a href="#a18ee73095b840748f6ebbe6d4047bd0e">More...</a><br /></td></tr>
<tr class="separator:a18ee73095b840748f6ebbe6d4047bd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9d3b7cd1c084e9c89091716eb40eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classforpy_1_1_tree.html">Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ad2c9d3b7cd1c084e9c89091716eb40eb">fit_dprov</a> (std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> &gt; data_provider, const bool &amp;complete_dfs=true)</td></tr>
<tr class="memdesc:ad2c9d3b7cd1c084e9c89091716eb40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fitting function for a single tree.  <a href="#ad2c9d3b7cd1c084e9c89091716eb40eb">More...</a><br /></td></tr>
<tr class="separator:ad2c9d3b7cd1c084e9c89091716eb40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339f44dae73984e14d4a65e1813f4e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a339f44dae73984e14d4a65e1813f4e2a">predict_leaf</a> (const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;data, const <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> &amp;start_node=0, const std::function&lt; void(void *)&gt; &amp;dptf=nullptr) const</td></tr>
<tr class="memdesc:a339f44dae73984e14d4a65e1813f4e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the leaf id of the leaf where the given data will arrive.  <a href="#a339f44dae73984e14d4a65e1813f4e2a">More...</a><br /></td></tr>
<tr class="separator:a339f44dae73984e14d4a65e1813f4e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a66b58b7cf5d1bb81f044ebf7970901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a5a66b58b7cf5d1bb81f044ebf7970901">predict</a> (const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;data_v, const int &amp;num_threads=1, const bool &amp;use_fast_prediction_if_available=true, const bool &amp;<a class="el" href="classforpy_1_1_tree.html#af407e82e843b92cbe9be90656395512d">predict_proba</a>=false, const bool &amp;for_forest=false)</td></tr>
<tr class="separator:a5a66b58b7cf5d1bb81f044ebf7970901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af407e82e843b92cbe9be90656395512d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#af407e82e843b92cbe9be90656395512d">predict_proba</a> (const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;data_v, const int &amp;num_threads=1, const bool &amp;use_fast_prediction_if_available=true)</td></tr>
<tr class="memdesc:af407e82e843b92cbe9be90656395512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for consistency with the sklearn interface.  <a href="#af407e82e843b92cbe9be90656395512d">More...</a><br /></td></tr>
<tr class="separator:af407e82e843b92cbe9be90656395512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7a83ed7c395bcfa0c5de78aff7c55b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a7a7a83ed7c395bcfa0c5de78aff7c55b">predict_leaf_result</a> (const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;data, const <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> &amp;start_node=0, const std::function&lt; void(void *)&gt; &amp;dptf=nullptr) const</td></tr>
<tr class="memdesc:a7a7a83ed7c395bcfa0c5de78aff7c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data prediction result for the given data.  <a href="#a7a7a83ed7c395bcfa0c5de78aff7c55b">More...</a><br /></td></tr>
<tr class="separator:a7a7a83ed7c395bcfa0c5de78aff7c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff75b3d58f747ce9fd97591503450c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#afff75b3d58f747ce9fd97591503450c6">combine_leaf_results</a> (const std::vector&lt; <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a> &gt;&gt; &amp;leaf_results, const <a class="el" href="namespaceforpy.html#a36398396324079cc112b2c14d72ef20d">Vec</a>&lt; float &gt; &amp;weights=<a class="el" href="namespaceforpy.html#a36398396324079cc112b2c14d72ef20d">Vec</a>&lt; float &gt;(), const bool &amp;<a class="el" href="classforpy_1_1_tree.html#af407e82e843b92cbe9be90656395512d">predict_proba</a>=false) const</td></tr>
<tr class="separator:afff75b3d58f747ce9fd97591503450c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34a6102319922edfe7e87deb0ef7a31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ae34a6102319922edfe7e87deb0ef7a31">is_initialized</a> () const</td></tr>
<tr class="memdesc:ae34a6102319922edfe7e87deb0ef7a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the trees <a class="el" href="classforpy_1_1_tree.html#a18ee73095b840748f6ebbe6d4047bd0e">fit</a> method has been called and its DFS and BFS methods can now be used.  <a href="#ae34a6102319922edfe7e87deb0ef7a31">More...</a><br /></td></tr>
<tr class="separator:ae34a6102319922edfe7e87deb0ef7a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbfbed6ba0300fa1ca7d6768aee6d10"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#afbbfbed6ba0300fa1ca7d6768aee6d10">get_weight</a> () const</td></tr>
<tr class="memdesc:afbbfbed6ba0300fa1ca7d6768aee6d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tree weight.  <a href="#afbbfbed6ba0300fa1ca7d6768aee6d10">More...</a><br /></td></tr>
<tr class="separator:afbbfbed6ba0300fa1ca7d6768aee6d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6518d6bf8358c5e5f872c9050ce5c568"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a6518d6bf8358c5e5f872c9050ce5c568">get_n_nodes</a> () const</td></tr>
<tr class="memdesc:a6518d6bf8358c5e5f872c9050ce5c568"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tree nodes.  <a href="#a6518d6bf8358c5e5f872c9050ce5c568">More...</a><br /></td></tr>
<tr class="separator:a6518d6bf8358c5e5f872c9050ce5c568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab58c599683c1d368e32ff8c5616ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#acab58c599683c1d368e32ff8c5616ca7">set_weight</a> (const float &amp;new_weight)</td></tr>
<tr class="memdesc:acab58c599683c1d368e32ff8c5616ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tree weight.  <a href="#acab58c599683c1d368e32ff8c5616ca7">More...</a><br /></td></tr>
<tr class="separator:acab58c599683c1d368e32ff8c5616ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad92c076f735a8c63129ef4a301793a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a4ad92c076f735a8c63129ef4a301793a">get_input_data_dimensions</a> () const</td></tr>
<tr class="memdesc:a4ad92c076f735a8c63129ef4a301793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data dimension that is required by this tree.  <a href="#a4ad92c076f735a8c63129ef4a301793a">More...</a><br /></td></tr>
<tr class="separator:a4ad92c076f735a8c63129ef4a301793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac6a894a91e33d620f2c1bc68b427bb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classforpy_1_1_i_decider.html">IDecider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a2ac6a894a91e33d620f2c1bc68b427bb">get_decider</a> () const</td></tr>
<tr class="memdesc:a2ac6a894a91e33d620f2c1bc68b427bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The classifier manager used by this tree.  <a href="#a2ac6a894a91e33d620f2c1bc68b427bb">More...</a><br /></td></tr>
<tr class="separator:a2ac6a894a91e33d620f2c1bc68b427bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33a3e582ea38b9cf20984b307bbc76b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classforpy_1_1_i_leaf.html">ILeaf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ae33a3e582ea38b9cf20984b307bbc76b">get_leaf_manager</a> () const</td></tr>
<tr class="memdesc:ae33a3e582ea38b9cf20984b307bbc76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The leaf manager used by this tree.  <a href="#ae33a3e582ea38b9cf20984b307bbc76b">More...</a><br /></td></tr>
<tr class="separator:ae33a3e582ea38b9cf20984b307bbc76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58763b59096bc3da795ff908ec99e320"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a58763b59096bc3da795ff908ec99e320">get_samples_stored</a> () const</td></tr>
<tr class="memdesc:a58763b59096bc3da795ff908ec99e320"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of samples stored in leafs.  <a href="#a58763b59096bc3da795ff908ec99e320">More...</a><br /></td></tr>
<tr class="separator:a58763b59096bc3da795ff908ec99e320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a088d0ae731e18077df3cc0595ce32b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair&lt; <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>, <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a3a088d0ae731e18077df3cc0595ce32b">get_tree</a> () const</td></tr>
<tr class="separator:a3a088d0ae731e18077df3cc0595ce32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf950617741fdb9b495c3d68a0885eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#aaf950617741fdb9b495c3d68a0885eea">enable_fast_prediction</a> ()</td></tr>
<tr class="separator:aaf950617741fdb9b495c3d68a0885eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940aa1b2516a8fc6edee66f21c52cf12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a940aa1b2516a8fc6edee66f21c52cf12">disable_fast_prediction</a> ()</td></tr>
<tr class="separator:a940aa1b2516a8fc6edee66f21c52cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb61c1db5f21236d020afd11aabcf5e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#adb61c1db5f21236d020afd11aabcf5e9">operator==</a> (<a class="el" href="classforpy_1_1_tree.html">Tree</a> const &amp;rhs) const</td></tr>
<tr class="separator:adb61c1db5f21236d020afd11aabcf5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ff0d0b1705f026398ea449fc06b6ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#af2ff0d0b1705f026398ea449fc06b6ea">save</a> (const std::string &amp;filename) const</td></tr>
<tr class="memdesc:af2ff0d0b1705f026398ea449fc06b6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the tree.  <a href="#af2ff0d0b1705f026398ea449fc06b6ea">More...</a><br /></td></tr>
<tr class="separator:af2ff0d0b1705f026398ea449fc06b6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2b8d5817874cb6ab06d7e4bd4b290163"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a2b8d5817874cb6ab06d7e4bd4b290163"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a2b8d5817874cb6ab06d7e4bd4b290163">serialize</a> (Archive &amp;ar, const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;)</td></tr>
<tr class="separator:a2b8d5817874cb6ab06d7e4bd4b290163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfde2b7295597451c98affd002c3ff23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#acfde2b7295597451c98affd002c3ff23">DISALLOW_COPY_AND_ASSIGN</a> (<a class="el" href="classforpy_1_1_tree.html">Tree</a>)</td></tr>
<tr class="separator:acfde2b7295597451c98affd002c3ff23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab5f61943c13ee4a49cee80379688bf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ab5f61943c13ee4a49cee80379688bf64">max_depth</a></td></tr>
<tr class="separator:ab5f61943c13ee4a49cee80379688bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c1a3ec2c1ea2bd7af98777490cd9e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a98c1a3ec2c1ea2bd7af98777490cd9e9">is_initialized_for_training</a></td></tr>
<tr class="separator:a98c1a3ec2c1ea2bd7af98777490cd9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c0a49605a095981066f865a5cddfd5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a65c0a49605a095981066f865a5cddfd5">min_samples_at_node</a></td></tr>
<tr class="separator:a65c0a49605a095981066f865a5cddfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbda07d8785ef47b669607621af59d11"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#abbda07d8785ef47b669607621af59d11">min_samples_at_leaf</a></td></tr>
<tr class="separator:abbda07d8785ef47b669607621af59d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4d08e4aa697fe33cc4c78eba6f6bb9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a6b4d08e4aa697fe33cc4c78eba6f6bb9">weight</a></td></tr>
<tr class="separator:a6b4d08e4aa697fe33cc4c78eba6f6bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a4f0f4fd0898375162ace44ee1a61"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a3d7a4f0f4fd0898375162ace44ee1a61">stored_in_leafs</a></td></tr>
<tr class="separator:a3d7a4f0f4fd0898375162ace44ee1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a6ab26fac8f02143edc7ca86f55c40"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_decider.html">IDecider</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ab5a6ab26fac8f02143edc7ca86f55c40">decider</a></td></tr>
<tr class="separator:ab5a6ab26fac8f02143edc7ca86f55c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2020df1c36fe0a935ea9ec2e6355b6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_leaf.html">ILeaf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#aaf2020df1c36fe0a935ea9ec2e6355b6">leaf_manager</a></td></tr>
<tr class="separator:aaf2020df1c36fe0a935ea9ec2e6355b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fccccd44acd59ec0235131d965d1a2e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>, <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a1fccccd44acd59ec0235131d965d1a2e">tree</a></td></tr>
<tr class="separator:a1fccccd44acd59ec0235131d965d1a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca27a6f06e9d51c4f57a2b6728f78de2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mu::variant&lt; std::vector&lt; std::tuple&lt; size_t, float, size_t, size_t &gt; &gt;, std::vector&lt; std::tuple&lt; size_t, double, size_t, size_t &gt; &gt;, std::vector&lt; std::tuple&lt; size_t, uint32_t, size_t, size_t &gt; &gt;, std::vector&lt; std::tuple&lt; size_t, uint8_t, size_t, size_t &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#aca27a6f06e9d51c4f57a2b6728f78de2">fast_tree</a></td></tr>
<tr class="separator:aca27a6f06e9d51c4f57a2b6728f78de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33106bed03867b2489dae54f5c5500a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ab33106bed03867b2489dae54f5c5500a">futures</a></td></tr>
<tr class="separator:ab33106bed03867b2489dae54f5c5500a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb03748fbbd6306b56b7470586c4845"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a3fb03748fbbd6306b56b7470586c4845">fut_mtx</a></td></tr>
<tr class="separator:a3fb03748fbbd6306b56b7470586c4845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d82b4527282466155d649b66205af6c"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a5d82b4527282466155d649b66205af6c">next_id</a></td></tr>
<tr class="separator:a5d82b4527282466155d649b66205af6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e72e2f34aa0b4cc540c74a66b806e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a6e72e2f34aa0b4cc540c74a66b806e26">random_seed</a></td></tr>
<tr class="separator:a6e72e2f34aa0b4cc540c74a66b806e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7c6b5c8100b27b9c3692820d4d40bd50"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#a7c6b5c8100b27b9c3692820d4d40bd50">forpy::Forest</a></td></tr>
<tr class="separator:a7c6b5c8100b27b9c3692820d4d40bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f44cbb59a08132f4c843e5225bba0e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#ab2f44cbb59a08132f4c843e5225bba0e">cereal::access</a></td></tr>
<tr class="separator:ab2f44cbb59a08132f4c843e5225bba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb9578d7828ae7e52f60203e1c4f4b6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classforpy_1_1_tree.html#aadb9578d7828ae7e52f60203e1c4f4b6">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classforpy_1_1_tree.html">Tree</a> &amp;self)</td></tr>
<tr class="separator:aadb9578d7828ae7e52f60203e1c4f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main tree class for the forpy framework. </p>
<p>This class is the core element of the framework. It can be used as a standalone tree or to form a forest. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00036">36</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afa48b090a00bb0557146bb3d5fb45f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa48b090a00bb0557146bb3d5fb45f3f">&#9670;&nbsp;</a></span>Tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">forpy::Tree::Tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a>&#160;&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;&#160;</td>
          <td class="paramname"><em>min_samples_at_leaf</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;&#160;</td>
          <td class="paramname"><em>min_samples_at_node</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_decider.html">IDecider</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>decider</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_leaf.html">ILeaf</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_manager</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The standard constructor for the forpy trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>uint &gt; 0 The maximum tree depth, including leafs (up to including). </td></tr>
    <tr><td class="paramname">min_samples_at_leaf</td><td>uint &gt; 0 The minimum number of samples at a leaf (from including). </td></tr>
    <tr><td class="paramname">min_samples_at_node</td><td>uint&gt;=2*min_samples_at_leaf The minimum number of samples at a node (from including). </td></tr>
    <tr><td class="paramname">decider</td><td><a class="el" href="classforpy_1_1_i_decider.html">IDecider</a> The decider that stores, optimizes and applies the decision rules for each inner tree node. </td></tr>
    <tr><td class="paramname">leaf_manager</td><td>The leaf manager generates, stores and handles the return values of the leaf nodes. </td></tr>
    <tr><td class="paramname">random_seed</td><td>uint&gt;0 Seed for the random engine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1e134d460ce946ed75527a84769e26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e134d460ce946ed75527a84769e26e">&#9670;&nbsp;</a></span>Tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">forpy::Tree::Tree </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialization constructor for the forpy trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string The filename to deserialize the tree from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afff75b3d58f747ce9fd97591503450c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff75b3d58f747ce9fd97591503450c6">&#9670;&nbsp;</a></span>combine_leaf_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt;<a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a>&gt; forpy::Tree::combine_leaf_results </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>leaf_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a36398396324079cc112b2c14d72ef20d">Vec</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em> = <code><a class="el" href="namespaceforpy.html#a36398396324079cc112b2c14d72ef20d">Vec</a>&lt;float&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>predict_proba</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Combine the leaf results of several trees to the forest result. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00227">227</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a0e21f03982ebee32e02292b2d0ca2322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e21f03982ebee32e02292b2d0ca2322">&#9670;&nbsp;</a></span>DFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::DFS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *&#160;</td>
          <td class="paramname"><em>data_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#adad607d1828338b79a86c36984d87e82">ECompletionLevel</a> &amp;&#160;</td>
          <td class="paramname"><em>completion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structforpy_1_1_desk.html">Desk</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do one DFS step with given completion level. </p>
<p>For <a class="el" href="namespaceforpy.html#adad607d1828338b79a86c36984d87e82aa0db49ba470c1c9ae2128c3470339153">CompletionLevel::Level</a>, the branch of the tree below the currently marked node is completed.</p>
<p>The function is to be used within a thread (see <a class="el" href="classforpy_1_1_tree.html#a1b561eb3d6e7328d43e5d09f8e439268">forpy::Tree::parallel_DFS</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_provider</td><td><a class="el" href="classforpy_1_1_i_data_provider.html" title="A data provider for the training of one tree. ">forpy::IDataProvider</a>* The data provider to use to get the samples with the relevant ids. </td></tr>
    <tr><td class="paramname">completion</td><td>CompletionLevel The <a class="el" href="namespaceforpy.html#adad607d1828338b79a86c36984d87e82">ECompletionLevel</a> to reach before returning from the function. </td></tr>
    <tr><td class="paramname">d</td><td><a class="el" href="structforpy_1_1_desk.html" title="Main thread desk object. ">Desk</a> <a class="el" href="structforpy_1_1_desk.html" title="Main thread desk object. ">Desk</a> to use thread local memory from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3387743826c6dbcda481391667e0cd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3387743826c6dbcda481391667e0cd66">&#9670;&nbsp;</a></span>DFS_and_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::DFS_and_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforpy_1_1_desk.html">Desk</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structforpy_1_1_todo_mark.html">TodoMark</a> &amp;&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *&#160;</td>
          <td class="paramname"><em>dprov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#adad607d1828338b79a86c36984d87e82">ECompletionLevel</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a940aa1b2516a8fc6edee66f21c52cf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940aa1b2516a8fc6edee66f21c52cf12">&#9670;&nbsp;</a></span>disable_fast_prediction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::disable_fast_prediction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees the memory from the unpacked trees for fast predictions. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00297">297</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="acfde2b7295597451c98affd002c3ff23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfde2b7295597451c98affd002c3ff23">&#9670;&nbsp;</a></span>DISALLOW_COPY_AND_ASSIGN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">forpy::Tree::DISALLOW_COPY_AND_ASSIGN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforpy_1_1_tree.html">Tree</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf950617741fdb9b495c3d68a0885eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf950617741fdb9b495c3d68a0885eea">&#9670;&nbsp;</a></span>enable_fast_prediction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::enable_fast_prediction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpack the hash maps for thresholds and feature IDs for fast predictions.</p>
<p>This only works for trees with threshold deciders and AlignedSurfaceCalcluators for the features. Requires more memory than the default trees, but is significantly faster. </p>

</div>
</div>
<a id="a18ee73095b840748f6ebbe6d4047bd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ee73095b840748f6ebbe6d4047bd0e">&#9670;&nbsp;</a></span>fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforpy_1_1_tree.html">Tree</a>* forpy::Tree::fit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>annotation_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>n_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>complete_dfs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em> = <code>std::vector&lt;&#160;float&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard fitting function. </p>
<p>Fits this tree to the data given by the data provider. If complete_dfs is true, the tree is completely fitted to the data Otherwise, just a node todo for the root node is added and the tree may be performed step-by-step by calling the <a class="el" href="namespaceforpy.html#a5a7b10963eacab5123565f04b2279001a838fea3c1a3e8dd6c22fe9605a701668">BFS</a> or <a class="el" href="classforpy_1_1_tree.html#a0e21f03982ebee32e02292b2d0ca2322">DFS</a> functions.</p>
<p>Releases the GIL in Python!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_v</td><td>Variant of 2D array, col-major contiguous Col-wise data points. </td></tr>
    <tr><td class="paramname">annotation_v</td><td>Variant of 2D array, row-major contiguous Row-wise annotations. </td></tr>
    <tr><td class="paramname">n_threads</td><td>size_t The number of threads to use. If set to 0, use all hardware threads. </td></tr>
    <tr><td class="paramname">complete_dfs</td><td>bool If set to true, finishes training the tree. Otherwise, the training is just set up, and <a class="el" href="classforpy_1_1_tree.html#a4fd94dc0367bea76936d4b577ba55d71">make_node</a> must be called. Default: true. </td></tr>
    <tr><td class="paramname">weights</td><td>vector&lt;float&gt; A vector with positive weights for each sample or an empty vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c9d3b7cd1c084e9c89091716eb40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c9d3b7cd1c084e9c89091716eb40eb">&#9670;&nbsp;</a></span>fit_dprov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classforpy_1_1_tree.html">Tree</a>* forpy::Tree::fit_dprov </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> &gt;&#160;</td>
          <td class="paramname"><em>data_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>complete_dfs</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The fitting function for a single tree. </p>
<p>Fits this tree to the data given by the data provider. If complete_dfs is true, the tree is completely fitted to the data Otherwise, just a node todo for the root node is added and the tree may be performed step-by-step by calling the <a class="el" href="namespaceforpy.html#a5a7b10963eacab5123565f04b2279001a838fea3c1a3e8dd6c22fe9605a701668">BFS</a> or <a class="el" href="classforpy_1_1_tree.html#a0e21f03982ebee32e02292b2d0ca2322">DFS</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_provider</td><td>shared(IDataProvider) The data provider for the fitting process. </td></tr>
    <tr><td class="paramname">complete_dfs</td><td>bool If true, complete the fitting process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ac6a894a91e33d620f2c1bc68b427bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac6a894a91e33d620f2c1bc68b427bb">&#9670;&nbsp;</a></span>get_decider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classforpy_1_1_i_decider.html">IDecider</a>&gt; forpy::Tree::get_decider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The classifier manager used by this tree. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00265">265</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a1b8177f98112a850f6240e17b275a61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8177f98112a850f6240e17b275a61a">&#9670;&nbsp;</a></span>get_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t forpy::Tree::get_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the tree depth.</p>
<p>The depth is defined to be 0 for an "empty" tree (only a leaf/root node) and as the amount of edges on the longest path in the tree otherwise. </p>

</div>
</div>
<a id="a4ad92c076f735a8c63129ef4a301793a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad92c076f735a8c63129ef4a301793a">&#9670;&nbsp;</a></span>get_input_data_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t forpy::Tree::get_input_data_dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The data dimension that is required by this tree. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00258">258</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="ae33a3e582ea38b9cf20984b307bbc76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33a3e582ea38b9cf20984b307bbc76b">&#9670;&nbsp;</a></span>get_leaf_manager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classforpy_1_1_i_leaf.html">ILeaf</a>&gt; forpy::Tree::get_leaf_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The leaf manager used by this tree. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00272">272</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a6518d6bf8358c5e5f872c9050ce5c568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6518d6bf8358c5e5f872c9050ce5c568">&#9670;&nbsp;</a></span>get_n_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t forpy::Tree::get_n_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of tree nodes. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00248">248</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a58763b59096bc3da795ff908ec99e320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58763b59096bc3da795ff908ec99e320">&#9670;&nbsp;</a></span>get_samples_stored()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t forpy::Tree::get_samples_stored </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of samples stored in leafs. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00279">279</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a3a088d0ae731e18077df3cc0595ce32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a088d0ae731e18077df3cc0595ce32b">&#9670;&nbsp;</a></span>get_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::pair&lt;<a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>, <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>&gt; &gt; forpy::Tree::get_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00281">281</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="afbbfbed6ba0300fa1ca7d6768aee6d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbfbed6ba0300fa1ca7d6768aee6d10">&#9670;&nbsp;</a></span>get_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float forpy::Tree::get_weight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The tree weight. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00243">243</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="ae34a6102319922edfe7e87deb0ef7a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34a6102319922edfe7e87deb0ef7a31">&#9670;&nbsp;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool forpy::Tree::is_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the trees <a class="el" href="classforpy_1_1_tree.html#a18ee73095b840748f6ebbe6d4047bd0e">fit</a> method has been called and its DFS and BFS methods can now be used. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00238">238</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a4fd94dc0367bea76936d4b577ba55d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd94dc0367bea76936d4b577ba55d71">&#9670;&nbsp;</a></span>make_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::make_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *&#160;</td>
          <td class="paramname"><em>data_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structforpy_1_1_desk.html">Desk</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle the creation of one tree node. </p>
<p>Takes the next one of the list of marked nodes and fits it to the data. If necessary, creates two child nodes and a split criterion, otherwise makes it a leaf.</p>
<p>The function is to be used within a thread (see <a class="el" href="classforpy_1_1_tree.html#a1b561eb3d6e7328d43e5d09f8e439268">forpy::Tree::parallel_DFS</a>). It is marked <code>const</code> so as to avoid concurrent writes to member elements. Everything that is written to must be available in a <a class="el" href="structforpy_1_1_desk.html" title="Main thread desk object. ">forpy::Desk</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_provider</td><td>shared(IDataProvider) The data provider to use. </td></tr>
    <tr><td class="paramname">d</td><td><a class="el" href="structforpy_1_1_desk.html" title="Main thread desk object. ">Desk</a> <a class="el" href="structforpy_1_1_desk.html" title="Main thread desk object. ">Desk</a> to use thread local memory from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb61c1db5f21236d020afd11aabcf5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb61c1db5f21236d020afd11aabcf5e9">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool forpy::Tree::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classforpy_1_1_tree.html">Tree</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b561eb3d6e7328d43e5d09f8e439268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b561eb3d6e7328d43e5d09f8e439268">&#9670;&nbsp;</a></span>parallel_DFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::parallel_DFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structforpy_1_1_desk.html">Desk</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structforpy_1_1_todo_mark.html">TodoMark</a> &amp;&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classforpy_1_1_i_data_provider.html">IDataProvider</a> *&#160;</td>
          <td class="paramname"><em>data_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>finalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a66b58b7cf5d1bb81f044ebf7970901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a66b58b7cf5d1bb81f044ebf7970901">&#9670;&nbsp;</a></span>predict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt;<a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a>&gt; forpy::Tree::predict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>use_fast_prediction_if_available</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>predict_proba</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>for_forest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predicts new data points.</p>
<p>Releases the GIL in Python!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_v</td><td>Variant of 2D data, row-major contiguous The data predict with one sample per row.</td></tr>
    <tr><td class="paramname">num_threads</td><td>int&gt;0 The number of threads to use for prediction. The number of samples should be at least three times larger than the number of threads to observe good parallelization behavior. Currently disabled.</td></tr>
    <tr><td class="paramname">use_fast_prediction_if_available</td><td>bool If set to true (default), this will create a compressed version of the tree that has particularly favorable properties for fast access and use it for predictions. You can trigger the creation manually by calling <a class="el" href="classforpy_1_1_tree.html#aaf950617741fdb9b495c3d68a0885eea">Tree::enable_fast_prediction</a>.</td></tr>
    <tr><td class="paramname">predict_proba</td><td>bool If enabled, will ask the leaf manager to provide probability information additionally to the prediction output.</td></tr>
    <tr><td class="paramname">for_forest</td><td>bool If set to true, will create an intermediate result that can be fused to a whole forest result. Not relevant for end-users. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a339f44dae73984e14d4a65e1813f4e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339f44dae73984e14d4a65e1813f4e2a">&#9670;&nbsp;</a></span>predict_leaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> forpy::Tree::predict_leaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>start_node</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(void *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>dptf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the leaf id of the leaf where the given data will arrive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to propagate through the tree. </td></tr>
    <tr><td class="paramname">start_node</td><td>The node to start from, doesn't have to be the root. </td></tr>
    <tr><td class="paramname">dptf</td><td>Feature mapping function; disabled at the moment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node id of the leaf. </dd></dl>

</div>
</div>
<a id="a7a7a83ed7c395bcfa0c5de78aff7c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7a83ed7c395bcfa0c5de78aff7c55b">&#9670;&nbsp;</a></span>predict_leaf_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt;<a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a>&gt; forpy::Tree::predict_leaf_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>start_node</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(void *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>dptf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data prediction result for the given data. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00218">218</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="af407e82e843b92cbe9be90656395512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af407e82e843b92cbe9be90656395512d">&#9670;&nbsp;</a></span>predict_proba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt;<a class="el" href="namespaceforpy.html#a96f4b931f57ef7b106a2137e9b92939c">Mat</a>&gt; forpy::Tree::predict_proba </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#a724d37691de11a57b50b9935b5550a89">Data</a>&lt; <a class="el" href="namespaceforpy.html#a4a9ac2f76a00cbaa27aa5c24ff4074a5">MatCRef</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>use_fast_prediction_if_available</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for consistency with the sklearn interface. </p>
<p><a class="el" href="classforpy_1_1_tree.html#a5a66b58b7cf5d1bb81f044ebf7970901">Tree::predict</a>. </p>

</div>
</div>
<a id="af2ff0d0b1705f026398ea449fc06b6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ff0d0b1705f026398ea449fc06b6ea">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string The filename of the file to store the tree in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b8d5817874cb6ab06d7e4bd4b290163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8d5817874cb6ab06d7e4bd4b290163">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00322">322</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="acab58c599683c1d368e32ff8c5616ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab58c599683c1d368e32ff8c5616ca7">&#9670;&nbsp;</a></span>set_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void forpy::Tree::set_weight </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>new_weight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the tree weight. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00253">253</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab2f44cbb59a08132f4c843e5225bba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f44cbb59a08132f4c843e5225bba0e">&#9670;&nbsp;</a></span>cereal::access</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class cereal::access</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00320">320</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a7c6b5c8100b27b9c3692820d4d40bd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6b5c8100b27b9c3692820d4d40bd50">&#9670;&nbsp;</a></span>forpy::Forest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classforpy_1_1_forest.html">forpy::Forest</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00316">316</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="aadb9578d7828ae7e52f60203e1c4f4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb9578d7828ae7e52f60203e1c4f4b6">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classforpy_1_1_tree.html">Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00312">312</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab5a6ab26fac8f02143edc7ca86f55c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a6ab26fac8f02143edc7ca86f55c40">&#9670;&nbsp;</a></span>decider</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classforpy_1_1_i_decider.html">IDecider</a>&gt; forpy::Tree::decider</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The associated classifier manager. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00349">349</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="aca27a6f06e9d51c4f57a2b6728f78de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca27a6f06e9d51c4f57a2b6728f78de2">&#9670;&nbsp;</a></span>fast_tree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mu::variant&lt;std::vector&lt;std::tuple&lt;size_t, float, size_t, size_t&gt; &gt;, std::vector&lt;std::tuple&lt;size_t, double, size_t, size_t&gt; &gt;, std::vector&lt;std::tuple&lt;size_t, uint32_t, size_t, size_t&gt; &gt;, std::vector&lt;std::tuple&lt;size_t, uint8_t, size_t, size_t&gt; &gt; &gt; &gt; forpy::Tree::fast_tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to a structure that can be used for fast predictions.</p>
<p>Vector ids are node ids. The first value in the tuple is the threshold value at that node. If the first and second tuple elements are the same, they contain a leaf ID. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00365">365</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a3fb03748fbbd6306b56b7470586c4845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb03748fbbd6306b56b7470586c4845">&#9670;&nbsp;</a></span>fut_mtx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex forpy::Tree::fut_mtx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00367">367</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="ab33106bed03867b2489dae54f5c5500a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33106bed03867b2489dae54f5c5500a">&#9670;&nbsp;</a></span>futures</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::future&lt;void&gt; &gt; forpy::Tree::futures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00366">366</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a98c1a3ec2c1ea2bd7af98777490cd9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c1a3ec2c1ea2bd7af98777490cd9e9">&#9670;&nbsp;</a></span>is_initialized_for_training</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool forpy::Tree::is_initialized_for_training</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether the <a class="el" href="classforpy_1_1_tree.html#a18ee73095b840748f6ebbe6d4047bd0e">fit</a> method has been called and the DFS and BFS methods can now be used for training. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00339">339</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="aaf2020df1c36fe0a935ea9ec2e6355b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2020df1c36fe0a935ea9ec2e6355b6">&#9670;&nbsp;</a></span>leaf_manager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classforpy_1_1_i_leaf.html">ILeaf</a>&gt; forpy::Tree::leaf_manager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The associated leaf manager. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00351">351</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="ab5f61943c13ee4a49cee80379688bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f61943c13ee4a49cee80379688bf64">&#9670;&nbsp;</a></span>max_depth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> forpy::Tree::max_depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum depth of the tree. Non-const for serialization purposes only. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00328">328</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="abbda07d8785ef47b669607621af59d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbda07d8785ef47b669607621af59d11">&#9670;&nbsp;</a></span>min_samples_at_leaf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int forpy::Tree::min_samples_at_leaf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The minimum number of samples that must arrive at a leaf. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00343">343</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a65c0a49605a095981066f865a5cddfd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c0a49605a095981066f865a5cddfd5">&#9670;&nbsp;</a></span>min_samples_at_node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int forpy::Tree::min_samples_at_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The minimum number of samples that must arrive at an inner node. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00341">341</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a5d82b4527282466155d649b66205af6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d82b4527282466155d649b66205af6c">&#9670;&nbsp;</a></span>next_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>&gt; forpy::Tree::next_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00368">368</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a6e72e2f34aa0b4cc540c74a66b806e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e72e2f34aa0b4cc540c74a66b806e26">&#9670;&nbsp;</a></span>random_seed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceforpy.html#ad05e34c62859518b61b76b5085e913d8">uint</a> forpy::Tree::random_seed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00369">369</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a3d7a4f0f4fd0898375162ace44ee1a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a4f0f4fd0898375162ace44ee1a61">&#9670;&nbsp;</a></span>stored_in_leafs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;size_t&gt; forpy::Tree::stored_in_leafs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The amount of samples stored in leafs so far. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00347">347</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a1fccccd44acd59ec0235131d965d1a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fccccd44acd59ec0235131d965d1a2e">&#9670;&nbsp;</a></span>tree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>, <a class="el" href="namespaceforpy.html#a324c9643e02b76477c3a99a48773be8c">id_t</a>&gt; &gt; forpy::Tree::tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds the entire tree structure. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00353">353</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<a id="a6b4d08e4aa697fe33cc4c78eba6f6bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4d08e4aa697fe33cc4c78eba6f6bb9">&#9670;&nbsp;</a></span>weight</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float forpy::Tree::weight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A weight assigned to this tree. Can be used by learning algorithms. </p>

<p class="definition">Definition at line <a class="el" href="tree_8h_source.html#l00345">345</a> of file <a class="el" href="tree_8h_source.html">tree.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/classner/git/forpy/include/forpy/<a class="el" href="tree_8h_source.html">tree.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
        <li class="navelem"><a class="el" href="namespaceforpy.html">forpy</a></li><li class="navelem"><a class="el" href="classforpy_1_1_tree.html">Tree</a></li>
        <li class="footer">Generated on Sat Feb 10 2018 01:06:57 for forpy by
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
    </ul>
</div>
</body>
</html>
