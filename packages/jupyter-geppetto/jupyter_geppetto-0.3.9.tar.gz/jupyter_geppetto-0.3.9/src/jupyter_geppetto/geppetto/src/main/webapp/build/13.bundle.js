webpackJsonp([13],{

/***/ 1432:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Controller class for popup widget. Use to make calls to widget from inside Geppetto.\n *\n * @author Jesus R Martinez (jesus@metacell.us)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var AWidgetController = __webpack_require__(596);\n\n    /**\n     * @exports Widgets/Popup/PopupsController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize(config) {\n            this.widgets = Array();\n            this.history = [];\n            if (config != null || undefined) {\n                this.buttonBarConfig = config.buttonBarConfiguration;\n            }\n        },\n\n        /**\n         * Creates popup widget\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                isStateless = false;\n            }\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(29).then((function (require) {\n\n                    var Popup = __webpack_require__(2660);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"Popup\", that.widgets);\n                    var name = id;\n\n                    //create popup widget\n                    var p = window[name] = new Popup({\n                        id: id, name: name, visible: true, controller: that,\n                        widgetType: GEPPETTO.Widgets.POPUP, stateless: isStateless\n                    });\n                    p.setController(that);\n                    p.setSize(394, 490);\n                    //create help command for plot\n                    p.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n\n                    //store in local stack\n                    that.widgets.push(p);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //add commands to console autocomplete and help option\n                    GEPPETTO.CommandController.updateHelpCommand(p, id, that.getFileComments(\"geppetto/js/components/widgets/popup/Popup.js\"));\n\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(p.getId(), p);\n\n                    resolve(p);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n        /**\n         * Receives updates from widget listener class to update popup widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event) {\n            //delete popup widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/popup/controllers/PopupController.js\n// module id = 1432\n// module chunks = 13\n\n//# sourceURL=webpack:///./js/components/widgets/popup/controllers/PopupController.js?");

/***/ }),

/***/ 1433:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Controller class for treevisualiser widget. Use to make calls to widget from\n * inside Geppetto.\n *\n * @module Widgets/TreeVisualizerControllerDAT\n *\n * @author Adrian Quintana (adrian.perez@ucl.ac.uk)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n    var AWidgetController = __webpack_require__(596);\n\n    /**\n     * @exports Widgets/Connectivity/TreeVisualiserControllerDATController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = [];\n        },\n\n        /**\n         * Adds a new TreeVisualizerDAT Widget to Geppetto\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                // stateless by default\n                isStateless = true;\n            }\n\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(30).then((function (require) {\n\n                    var TreeVisualiserDAT = __webpack_require__(2674);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"TreeVisualiserDAT\", that.widgets);\n                    var name = id;\n\n                    // create tree visualiser widget\n                    var tvdat = window[name] = new TreeVisualiserDAT({\n                        id: id, name: name, visible: true, width: 260, height: 350,\n                        widgetType: GEPPETTO.Widgets.TREEVISUALISERDAT, stateless: isStateless\n                    });\n                    // create help command for plot\n                    tvdat.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n                    // store in local stack\n                    that.widgets.push(tvdat);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    // updates helpc command output\n                    GEPPETTO.CommandController.updateHelpCommand(tvdat, id, that.getFileComments(\"geppetto/js/components/widgets/treevisualiser/treevisualiserdat/TreeVisualiserDAT.js\"));\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(tvdat.getId(), tvdat);\n\n                    resolve(tvdat);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update TreeVisualizerDAT widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event, parameters) {\n            var treeVisualisersDAT = this.getWidgets();\n            // delete treevisualiser widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            } else if (event == GEPPETTO.Events.Select) {\n                //loop through all existing widgets\n                for (var i = 0; i < this.widgets.length; i++) {\n                    var treeVisualiserDAT = this.widgets[i];\n\n                    if (_.find(treeVisualiserDAT.registeredEvents, function (el) {\n                        return el.id === event;\n                    })) {\n                        var selected = GEPPETTO.SceneController.getSelection();\n                        treeVisualiserDAT.reset();\n                        //update treevisualiser with new data set\n                        treeVisualiserDAT.setData(selected[0]);\n                    }\n                }\n            }\n            // update treevisualiser widgets\n            else if (event == GEPPETTO.Events.Experiment_update) {\n                    // loop through all existing widgets\n                    for (var i = 0; i < treeVisualisersDAT.length; i++) {\n                        var treeVisualiserDAT = treeVisualisersDAT[i];\n\n                        // update treevisualiser with new data set\n                        treeVisualiserDAT.updateData(parameters.step);\n                    }\n                }\n                // update treevisualiser widgets\n                else if (event == GEPPETTO.Events.ModelTree_populated || event == GEPPETTO.Events.SimulationTree_populated) {\n                        // loop through all existing widgets\n                        for (var i = 0; i < treeVisualisersDAT.length; i++) {\n                            var treeVisualiserDAT = treeVisualisersDAT[i];\n\n                            var ev = _.find(treeVisualiserDAT.registeredEvents, function (el) {\n                                return el.id === event;\n                            });\n                            if (typeof ev !== 'undefined') {\n                                if (typeof ev.callback === 'undefined') {\n                                    //TODO: We need the event data here so we can decide if we would like to refresh or not\n                                    treeVisualiserDAT.refresh();\n                                } else {\n                                    ev.callback();\n                                }\n                            }\n                        }\n                    }\n        },\n\n        /**\n         * Retrieve commands for a specific variable node\n         *\n         * @param {Node} node - Geppetto Node used for extracting commands\n         * @returns {Array} Set of commands associated with this node\n         */\n        getCommands: function getCommands(node) {\n            var group1 = [{\n                label: \"Open with DAT Widget\",\n                action: [\"G.addWidget(Widgets.TREEVISUALISERDAT).setData(\" + node.getPath() + \")\"]\n            }];\n\n            var availableWidgets = GEPPETTO.WidgetFactory.getController(GEPPETTO.Widgets.TREEVISUALISERDAT).getWidgets();\n            if (availableWidgets.length > 0) {\n                var group1Add = {\n                    label: \"Add to DAT Widget\",\n                    position: 0\n                };\n\n                var subgroups1Add = [];\n                for (var availableWidgetIndex in availableWidgets) {\n                    var availableWidget = availableWidgets[availableWidgetIndex];\n                    subgroups1Add = subgroups1Add.concat([{\n                        label: \"Add to \" + availableWidget.name,\n                        action: [availableWidget.id + \".setData(\" + node.getPath() + \")\"],\n                        position: availableWidgetIndex\n                    }]);\n                }\n                group1Add[\"groups\"] = [subgroups1Add];\n\n                group1.push(group1Add);\n            }\n\n            var groups = [group1];\n\n            if (node.getMetaType() == GEPPETTO.Resources.COMPOSITE_TYPE_NODE && node.getWrappedObj().getVisualType() != undefined) {\n                var entity = [{\n                    label: \"Select Visual Component\",\n                    action: [\"GEPPETTO.SceneController.deselectAll();\", node.getPath() + \".select()\"]\n                }];\n\n                groups.push(entity);\n            }\n\n            if (node.getMetaType() == GEPPETTO.Resources.VISUAL_GROUP_NODE) {\n                var visualGroup = [{\n                    label: \"Show Visual Groups\",\n                    action: [\"GEPPETTO.SceneController.deselectAll();\", node.getPath() + \".show(true)\"]\n                }];\n\n                groups.push(visualGroup);\n            }\n\n            if (node.getWrappedObj().capabilities != null && node.getWrappedObj().capabilities.length > 0 && node.getWrappedObj().capabilities.indexOf('VisualGroupCapability') != -1) {\n                var visualGroup = [{\n                    label: \"Show Visual Groups\"\n                }];\n\n                var subgroups1Add = [];\n                for (var visualGroupIndex in node.getWrappedObj().getVisualGroups()) {\n                    subgroups1Add = subgroups1Add.concat([{\n                        label: \"Show \" + node.getWrappedObj().getVisualGroups()[visualGroupIndex].getName(),\n                        action: [\"GEPPETTO.SceneController.deselectAll();\", node.getPath() + \".applyVisualGroup(\" + node.getPath() + \".getVisualGroups()[\" + visualGroupIndex + \"], true)\"],\n                        position: visualGroupIndex\n                    }]);\n                }\n                visualGroup[0][\"groups\"] = [subgroups1Add];\n\n                groups.push(visualGroup);\n            }\n\n            return groups;\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/treevisualiser/treevisualiserdat/controllers/TreeVisualiserControllerDAT.js\n// module id = 1433\n// module chunks = 13\n\n//# sourceURL=webpack:///./js/components/widgets/treevisualiser/treevisualiserdat/controllers/TreeVisualiserControllerDAT.js?");

/***/ }),

/***/ 1434:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Controller class for variables visualiser widget.\n *\n * @author Dan Kruchinin (dkruchinin@acm.org)\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var AWidgetController = __webpack_require__(596);\n\n    /**\n     * @exports Widgets/VariableVisualiser/VariableVisualiserController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = [];\n        },\n\n        /**\n         * Creates new variable visualiser widget\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                isStateless = false;\n            }\n\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(31).then((function (require) {\n                    var VarVis = __webpack_require__(2682);\n\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"VarVis\", that.widgets);\n                    var name = id;\n                    var vv = window[name] = new VarVis({\n                        id: id, name: name, visible: true,\n                        widgetType: GEPPETTO.Widgets.VARIABLEVISUALISER, stateless: isStateless\n                    });\n\n                    vv.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n\n                    // store in local stack\n                    that.widgets.push(vv);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //updates help command options\n                    GEPPETTO.CommandController.updateHelpCommand(vv, id, that.getFileComments(\"geppetto/js/components/widgets/variablevisualiser/VariableVisualiser.js\"));\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(vv.getId(), vv);\n                    resolve(vv);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update variable visualiser widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event, parameters) {\n            //delete a widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n            //update widgets\n            else if (event == GEPPETTO.Events.Experiment_update) {\n                    var step = parameters.step;\n                    for (var i = 0; i < this.widgets.length; i++) {\n                        this.widgets[i].updateVariable(step);\n                    }\n                }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/variablevisualiser/controllers/VariableVisualiserController.js\n// module id = 1434\n// module chunks = 13\n\n//# sourceURL=webpack:///./js/components/widgets/variablevisualiser/controllers/VariableVisualiserController.js?");

/***/ }),

/***/ 1435:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Controller class for connectivity widget. Use to make calls to widget from inside Geppetto.\n *\n * @constructor\n *\n * @module Widgets/Connectivity\n * @author Adrian Quintana (adrian.perez@ucl.ac.uk)\n * @author Boris Marin\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n    var AWidgetController = __webpack_require__(596);\n\n    /**\n     * @exports Widgets/Connectivity/ConnectivityController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = Array();\n            this.history = [];\n        },\n\n        configureConnectivityWidget: function configureConnectivityWidget() {\n            Connectivity.prototype.configViaGUI();\n        },\n\n        /**\n         * Adds a new Connectivity Widget to Geppetto\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                isStateless = false;\n            }\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(27).then((function (require) {\n                    var Connectivity = __webpack_require__(2685);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"Connectivity\", that.widgets);\n                    var name = id;\n\n                    //create tree visualiser widget\n                    var cnt = window[name] = new Connectivity({\n                        id: id, name: name, visible: false, width: 500, height: 500, controller: that,\n                        widgetType: GEPPETTO.Widgets.CONNECTIVITY, stateless: isStateless\n                    });\n\n                    //create help command for connw\n                    cnt.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n\n                    //store in local stack\n                    that.widgets.push(cnt);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //add commands help option\n                    GEPPETTO.CommandController.updateHelpCommand(cnt, id, that.getFileComments(\"geppetto/js/components/widgets/connectivity/Connectivity.js\"));\n\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(cnt.getId(), cnt);\n\n                    resolve(cnt);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update TreeVisualizer3D widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event) {\n            //delete connectivity widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n            //update connectivity widgets\n            else if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.UPDATE) {\n                    //loop through all existing widgets\n                    for (var i = 0; i < this.widgets.length; i++) {\n                        var cnt = this.widgets[i];\n                        //update connectivity with new data set\n                        cnt.updateData();\n                    }\n                }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/connectivity/controllers/ConnectivityController.js\n// module id = 1435\n// module chunks = 13\n\n//# sourceURL=webpack:///./js/components/widgets/connectivity/controllers/ConnectivityController.js?");

/***/ }),

/***/ 1436:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Controller class for the stackViewer widget.\n *\n * @author Robbie1977\n */\n!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\n    var AWidgetController = __webpack_require__(596);\n\n    /**\n     * @exports Widgets/stackViewer/stackViewerController\n     */\n    return AWidgetController.View.extend({\n\n        initialize: function initialize() {\n            this.widgets = Array();\n            this.history = [];\n        },\n\n        /**\n         * Creates new stack viewer widget\n         */\n        addWidget: function addWidget(isStateless) {\n            if (isStateless == undefined) {\n                // stateless by default\n                isStateless = true;\n            }\n\n            var that = this;\n\n            return new Promise(function (resolve) {\n                __webpack_require__.e/* require.ensure */(28).then((function (require) {\n                    var Stack = __webpack_require__(2984);\n                    //look for a name and id for the new widget\n                    var id = that.getAvailableWidgetId(\"StackViewer\", that.widgets);\n                    var name = id;\n                    var vv = window[name] = new Stack({\n                        id: id, name: name, visible: true,\n                        widgetType: GEPPETTO.Widgets.STACKVIEWER, stateless: isStateless\n                    });\n                    vv.help = function () {\n                        return GEPPETTO.CommandController.getObjectCommands(id);\n                    };\n                    that.widgets.push(vv);\n\n                    GEPPETTO.WidgetsListener.subscribe(that, id);\n\n                    //updates help command options\n                    GEPPETTO.CommandController.updateHelpCommand(vv, id, that.getFileComments(\"geppetto/js/components/widgets/stackViewer/StackViewer.js\"));\n\n                    //update tags for autocompletion\n                    GEPPETTO.CommandController.updateTags(vv.getId(), vv);\n                    resolve(vv);\n                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);\n            });\n        },\n\n        /**\n         * Receives updates from widget listener class to update Button Bar widget(s)\n         *\n         * @param {WIDGET_EVENT_TYPE} event - Event that tells widgets what to do\n         */\n        update: function update(event) {\n            //delete a widget(s)\n            if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.DELETE) {\n                this.removeWidgets();\n            }\n\n            //reset widget's datasets\n            else if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.RESET_DATA) {}\n                //pass\n\n\n                //update widgets\n                else if (event == GEPPETTO.WidgetsListener.WIDGET_EVENT_TYPE.UPDATE) {\n                        //pass\n                    }\n        }\n    });\n}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/components/widgets/stackViewer/controllers/StackViewerController.js\n// module id = 1436\n// module chunks = 13\n\n//# sourceURL=webpack:///./js/components/widgets/stackViewer/controllers/StackViewerController.js?");

/***/ })

});