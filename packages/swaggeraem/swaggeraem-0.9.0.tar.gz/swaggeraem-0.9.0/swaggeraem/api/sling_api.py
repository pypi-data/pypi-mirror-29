# coding: utf-8

"""
    Adobe Experience Manager (AEM) API

    Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API  # noqa: E501

    OpenAPI spec version: 1.2.1
    Contact: opensource@shinesolutions.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swaggeraem.api_client import ApiClient


class SlingApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_agent(self, runmode, name, **kwargs):  # noqa: E501
        """delete_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_agent(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
            return data

    def delete_agent_with_http_info(self, runmode, name, **kwargs):  # noqa: E501
        """delete_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_agent_with_http_info(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `delete_agent`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node(self, path, name, **kwargs):  # noqa: E501
        """delete_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_node_with_http_info(path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_with_http_info(path, name, **kwargs)  # noqa: E501
            return data

    def delete_node_with_http_info(self, path, name, **kwargs):  # noqa: E501
        """delete_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_with_http_info(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_node`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agent(self, runmode, name, **kwargs):  # noqa: E501
        """get_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agent(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
            return data

    def get_agent_with_http_info(self, runmode, name, **kwargs):  # noqa: E501
        """get_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agent_with_http_info(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `get_agent`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_agents(self, runmode, **kwargs):  # noqa: E501
        """get_agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agents(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_agents_with_http_info(runmode, **kwargs)  # noqa: E501
        else:
            (data) = self.get_agents_with_http_info(runmode, **kwargs)  # noqa: E501
            return data

    def get_agents_with_http_info(self, runmode, **kwargs):  # noqa: E501
        """get_agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agents_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `get_agents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}.-1.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node(self, path, name, **kwargs):  # noqa: E501
        """get_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_node_with_http_info(path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_with_http_info(path, name, **kwargs)  # noqa: E501
            return data

    def get_node_with_http_info(self, path, name, **kwargs):  # noqa: E501
        """get_node  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node_with_http_info(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_node`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_node`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_package(self, group, name, version, **kwargs):  # noqa: E501
        """get_package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_package_with_http_info(group, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.get_package_with_http_info(group, name, version, **kwargs)  # noqa: E501
            return data

    def get_package_with_http_info(self, group, name, version, **kwargs):  # noqa: E501
        """get_package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package_with_http_info(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group', 'name', 'version']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_package" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group' is set
        if ('group' not in params or
                params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `get_package`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_package`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_package`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group' in params:
            path_params['group'] = params['group']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/packages/{group}/{name}-{version}.zip', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_package_filter(self, group, name, version, **kwargs):  # noqa: E501
        """get_package_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package_filter(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_package_filter_with_http_info(group, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.get_package_filter_with_http_info(group, name, version, **kwargs)  # noqa: E501
            return data

    def get_package_filter_with_http_info(self, group, name, version, **kwargs):  # noqa: E501
        """get_package_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package_filter_with_http_info(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group', 'name', 'version']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_package_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group' is set
        if ('group' not in params or
                params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `get_package_filter`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_package_filter`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_package_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group' in params:
            path_params['group'] = params['group']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_query(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """get_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_query(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
        else:
            (data) = self.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
            return data

    def get_query_with_http_info(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """get_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'p_limit', '_1_property', '_1_property_value']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_query" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_query`")  # noqa: E501
        # verify the required parameter 'p_limit' is set
        if ('p_limit' not in params or
                params['p_limit'] is None):
            raise ValueError("Missing the required parameter `p_limit` when calling `get_query`")  # noqa: E501
        # verify the required parameter '_1_property' is set
        if ('_1_property' not in params or
                params['_1_property'] is None):
            raise ValueError("Missing the required parameter `_1_property` when calling `get_query`")  # noqa: E501
        # verify the required parameter '_1_property_value' is set
        if ('_1_property_value' not in params or
                params['_1_property_value'] is None):
            raise ValueError("Missing the required parameter `_1_property_value` when calling `get_query`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'p_limit' in params:
            query_params.append(('p.limit', params['p_limit']))  # noqa: E501
        if '_1_property' in params:
            query_params.append(('1_property', params['_1_property']))  # noqa: E501
        if '_1_property_value' in params:
            query_params.append(('1_property.value', params['_1_property_value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bin/querybuilder.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_agent(self, runmode, name, **kwargs):  # noqa: E501
        """post_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_agent(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :param bool jcrcontentcqdistribute:
        :param str jcrcontentcqdistribute_type_hint:
        :param str jcrcontentcqname:
        :param str jcrcontentcqtemplate:
        :param bool jcrcontentenabled:
        :param str jcrcontentjcrdescription:
        :param str jcrcontentjcrlast_modified:
        :param str jcrcontentjcrlast_modified_by:
        :param str jcrcontentjcrmixin_types:
        :param str jcrcontentjcrtitle:
        :param str jcrcontentlog_level:
        :param bool jcrcontentno_status_update:
        :param bool jcrcontentno_versioning:
        :param float jcrcontentprotocol_connect_timeout:
        :param bool jcrcontentprotocol_http_connection_closed:
        :param str jcrcontentprotocol_http_expired:
        :param list[str] jcrcontentprotocol_http_headers:
        :param str jcrcontentprotocol_http_headers_type_hint:
        :param str jcrcontentprotocol_http_method:
        :param bool jcrcontentprotocol_https_relaxed:
        :param str jcrcontentprotocol_interface:
        :param float jcrcontentprotocol_socket_timeout:
        :param str jcrcontentprotocol_version:
        :param str jcrcontentproxy_ntlm_domain:
        :param str jcrcontentproxy_ntlm_host:
        :param str jcrcontentproxy_host:
        :param str jcrcontentproxy_password:
        :param float jcrcontentproxy_port:
        :param str jcrcontentproxy_user:
        :param float jcrcontentqueue_batch_max_size:
        :param str jcrcontentqueue_batch_mode:
        :param float jcrcontentqueue_batch_wait_time:
        :param str jcrcontentretry_delay:
        :param bool jcrcontentreverse_replication:
        :param str jcrcontentserialization_type:
        :param str jcrcontentslingresource_type:
        :param str jcrcontentssl:
        :param str jcrcontenttransport_ntlm_domain:
        :param str jcrcontenttransport_ntlm_host:
        :param str jcrcontenttransport_password:
        :param str jcrcontenttransport_uri:
        :param str jcrcontenttransport_user:
        :param bool jcrcontenttrigger_distribute:
        :param bool jcrcontenttrigger_modified:
        :param bool jcrcontenttrigger_on_off_time:
        :param bool jcrcontenttrigger_receive:
        :param bool jcrcontenttrigger_specific:
        :param str jcrcontentuser_id:
        :param str jcrprimary_type:
        :param str operation:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_agent_with_http_info(runmode, name, **kwargs)  # noqa: E501
            return data

    def post_agent_with_http_info(self, runmode, name, **kwargs):  # noqa: E501
        """post_agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_agent_with_http_info(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :param bool jcrcontentcqdistribute:
        :param str jcrcontentcqdistribute_type_hint:
        :param str jcrcontentcqname:
        :param str jcrcontentcqtemplate:
        :param bool jcrcontentenabled:
        :param str jcrcontentjcrdescription:
        :param str jcrcontentjcrlast_modified:
        :param str jcrcontentjcrlast_modified_by:
        :param str jcrcontentjcrmixin_types:
        :param str jcrcontentjcrtitle:
        :param str jcrcontentlog_level:
        :param bool jcrcontentno_status_update:
        :param bool jcrcontentno_versioning:
        :param float jcrcontentprotocol_connect_timeout:
        :param bool jcrcontentprotocol_http_connection_closed:
        :param str jcrcontentprotocol_http_expired:
        :param list[str] jcrcontentprotocol_http_headers:
        :param str jcrcontentprotocol_http_headers_type_hint:
        :param str jcrcontentprotocol_http_method:
        :param bool jcrcontentprotocol_https_relaxed:
        :param str jcrcontentprotocol_interface:
        :param float jcrcontentprotocol_socket_timeout:
        :param str jcrcontentprotocol_version:
        :param str jcrcontentproxy_ntlm_domain:
        :param str jcrcontentproxy_ntlm_host:
        :param str jcrcontentproxy_host:
        :param str jcrcontentproxy_password:
        :param float jcrcontentproxy_port:
        :param str jcrcontentproxy_user:
        :param float jcrcontentqueue_batch_max_size:
        :param str jcrcontentqueue_batch_mode:
        :param float jcrcontentqueue_batch_wait_time:
        :param str jcrcontentretry_delay:
        :param bool jcrcontentreverse_replication:
        :param str jcrcontentserialization_type:
        :param str jcrcontentslingresource_type:
        :param str jcrcontentssl:
        :param str jcrcontenttransport_ntlm_domain:
        :param str jcrcontenttransport_ntlm_host:
        :param str jcrcontenttransport_password:
        :param str jcrcontenttransport_uri:
        :param str jcrcontenttransport_user:
        :param bool jcrcontenttrigger_distribute:
        :param bool jcrcontenttrigger_modified:
        :param bool jcrcontenttrigger_on_off_time:
        :param bool jcrcontenttrigger_receive:
        :param bool jcrcontenttrigger_specific:
        :param str jcrcontentuser_id:
        :param str jcrprimary_type:
        :param str operation:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'name', 'jcrcontentcqdistribute', 'jcrcontentcqdistribute_type_hint', 'jcrcontentcqname', 'jcrcontentcqtemplate', 'jcrcontentenabled', 'jcrcontentjcrdescription', 'jcrcontentjcrlast_modified', 'jcrcontentjcrlast_modified_by', 'jcrcontentjcrmixin_types', 'jcrcontentjcrtitle', 'jcrcontentlog_level', 'jcrcontentno_status_update', 'jcrcontentno_versioning', 'jcrcontentprotocol_connect_timeout', 'jcrcontentprotocol_http_connection_closed', 'jcrcontentprotocol_http_expired', 'jcrcontentprotocol_http_headers', 'jcrcontentprotocol_http_headers_type_hint', 'jcrcontentprotocol_http_method', 'jcrcontentprotocol_https_relaxed', 'jcrcontentprotocol_interface', 'jcrcontentprotocol_socket_timeout', 'jcrcontentprotocol_version', 'jcrcontentproxy_ntlm_domain', 'jcrcontentproxy_ntlm_host', 'jcrcontentproxy_host', 'jcrcontentproxy_password', 'jcrcontentproxy_port', 'jcrcontentproxy_user', 'jcrcontentqueue_batch_max_size', 'jcrcontentqueue_batch_mode', 'jcrcontentqueue_batch_wait_time', 'jcrcontentretry_delay', 'jcrcontentreverse_replication', 'jcrcontentserialization_type', 'jcrcontentslingresource_type', 'jcrcontentssl', 'jcrcontenttransport_ntlm_domain', 'jcrcontenttransport_ntlm_host', 'jcrcontenttransport_password', 'jcrcontenttransport_uri', 'jcrcontenttransport_user', 'jcrcontenttrigger_distribute', 'jcrcontenttrigger_modified', 'jcrcontenttrigger_on_off_time', 'jcrcontenttrigger_receive', 'jcrcontenttrigger_specific', 'jcrcontentuser_id', 'jcrprimary_type', 'operation']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_agent`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_agent`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'jcrcontentcqdistribute' in params:
            query_params.append(('jcr:content/cq:distribute', params['jcrcontentcqdistribute']))  # noqa: E501
        if 'jcrcontentcqdistribute_type_hint' in params:
            query_params.append(('jcr:content/cq:distribute@TypeHint', params['jcrcontentcqdistribute_type_hint']))  # noqa: E501
        if 'jcrcontentcqname' in params:
            query_params.append(('jcr:content/cq:name', params['jcrcontentcqname']))  # noqa: E501
        if 'jcrcontentcqtemplate' in params:
            query_params.append(('jcr:content/cq:template', params['jcrcontentcqtemplate']))  # noqa: E501
        if 'jcrcontentenabled' in params:
            query_params.append(('jcr:content/enabled', params['jcrcontentenabled']))  # noqa: E501
        if 'jcrcontentjcrdescription' in params:
            query_params.append(('jcr:content/jcr:description', params['jcrcontentjcrdescription']))  # noqa: E501
        if 'jcrcontentjcrlast_modified' in params:
            query_params.append(('jcr:content/jcr:lastModified', params['jcrcontentjcrlast_modified']))  # noqa: E501
        if 'jcrcontentjcrlast_modified_by' in params:
            query_params.append(('jcr:content/jcr:lastModifiedBy', params['jcrcontentjcrlast_modified_by']))  # noqa: E501
        if 'jcrcontentjcrmixin_types' in params:
            query_params.append(('jcr:content/jcr:mixinTypes', params['jcrcontentjcrmixin_types']))  # noqa: E501
        if 'jcrcontentjcrtitle' in params:
            query_params.append(('jcr:content/jcr:title', params['jcrcontentjcrtitle']))  # noqa: E501
        if 'jcrcontentlog_level' in params:
            query_params.append(('jcr:content/logLevel', params['jcrcontentlog_level']))  # noqa: E501
        if 'jcrcontentno_status_update' in params:
            query_params.append(('jcr:content/noStatusUpdate', params['jcrcontentno_status_update']))  # noqa: E501
        if 'jcrcontentno_versioning' in params:
            query_params.append(('jcr:content/noVersioning', params['jcrcontentno_versioning']))  # noqa: E501
        if 'jcrcontentprotocol_connect_timeout' in params:
            query_params.append(('jcr:content/protocolConnectTimeout', params['jcrcontentprotocol_connect_timeout']))  # noqa: E501
        if 'jcrcontentprotocol_http_connection_closed' in params:
            query_params.append(('jcr:content/protocolHTTPConnectionClosed', params['jcrcontentprotocol_http_connection_closed']))  # noqa: E501
        if 'jcrcontentprotocol_http_expired' in params:
            query_params.append(('jcr:content/protocolHTTPExpired', params['jcrcontentprotocol_http_expired']))  # noqa: E501
        if 'jcrcontentprotocol_http_headers' in params:
            query_params.append(('jcr:content/protocolHTTPHeaders', params['jcrcontentprotocol_http_headers']))  # noqa: E501
            collection_formats['jcr:content/protocolHTTPHeaders'] = 'multi'  # noqa: E501
        if 'jcrcontentprotocol_http_headers_type_hint' in params:
            query_params.append(('jcr:content/protocolHTTPHeaders@TypeHint', params['jcrcontentprotocol_http_headers_type_hint']))  # noqa: E501
        if 'jcrcontentprotocol_http_method' in params:
            query_params.append(('jcr:content/protocolHTTPMethod', params['jcrcontentprotocol_http_method']))  # noqa: E501
        if 'jcrcontentprotocol_https_relaxed' in params:
            query_params.append(('jcr:content/protocolHTTPSRelaxed', params['jcrcontentprotocol_https_relaxed']))  # noqa: E501
        if 'jcrcontentprotocol_interface' in params:
            query_params.append(('jcr:content/protocolInterface', params['jcrcontentprotocol_interface']))  # noqa: E501
        if 'jcrcontentprotocol_socket_timeout' in params:
            query_params.append(('jcr:content/protocolSocketTimeout', params['jcrcontentprotocol_socket_timeout']))  # noqa: E501
        if 'jcrcontentprotocol_version' in params:
            query_params.append(('jcr:content/protocolVersion', params['jcrcontentprotocol_version']))  # noqa: E501
        if 'jcrcontentproxy_ntlm_domain' in params:
            query_params.append(('jcr:content/proxyNTLMDomain', params['jcrcontentproxy_ntlm_domain']))  # noqa: E501
        if 'jcrcontentproxy_ntlm_host' in params:
            query_params.append(('jcr:content/proxyNTLMHost', params['jcrcontentproxy_ntlm_host']))  # noqa: E501
        if 'jcrcontentproxy_host' in params:
            query_params.append(('jcr:content/proxyHost', params['jcrcontentproxy_host']))  # noqa: E501
        if 'jcrcontentproxy_password' in params:
            query_params.append(('jcr:content/proxyPassword', params['jcrcontentproxy_password']))  # noqa: E501
        if 'jcrcontentproxy_port' in params:
            query_params.append(('jcr:content/proxyPort', params['jcrcontentproxy_port']))  # noqa: E501
        if 'jcrcontentproxy_user' in params:
            query_params.append(('jcr:content/proxyUser', params['jcrcontentproxy_user']))  # noqa: E501
        if 'jcrcontentqueue_batch_max_size' in params:
            query_params.append(('jcr:content/queueBatchMaxSize', params['jcrcontentqueue_batch_max_size']))  # noqa: E501
        if 'jcrcontentqueue_batch_mode' in params:
            query_params.append(('jcr:content/queueBatchMode', params['jcrcontentqueue_batch_mode']))  # noqa: E501
        if 'jcrcontentqueue_batch_wait_time' in params:
            query_params.append(('jcr:content/queueBatchWaitTime', params['jcrcontentqueue_batch_wait_time']))  # noqa: E501
        if 'jcrcontentretry_delay' in params:
            query_params.append(('jcr:content/retryDelay', params['jcrcontentretry_delay']))  # noqa: E501
        if 'jcrcontentreverse_replication' in params:
            query_params.append(('jcr:content/reverseReplication', params['jcrcontentreverse_replication']))  # noqa: E501
        if 'jcrcontentserialization_type' in params:
            query_params.append(('jcr:content/serializationType', params['jcrcontentserialization_type']))  # noqa: E501
        if 'jcrcontentslingresource_type' in params:
            query_params.append(('jcr:content/sling:resourceType', params['jcrcontentslingresource_type']))  # noqa: E501
        if 'jcrcontentssl' in params:
            query_params.append(('jcr:content/ssl', params['jcrcontentssl']))  # noqa: E501
        if 'jcrcontenttransport_ntlm_domain' in params:
            query_params.append(('jcr:content/transportNTLMDomain', params['jcrcontenttransport_ntlm_domain']))  # noqa: E501
        if 'jcrcontenttransport_ntlm_host' in params:
            query_params.append(('jcr:content/transportNTLMHost', params['jcrcontenttransport_ntlm_host']))  # noqa: E501
        if 'jcrcontenttransport_password' in params:
            query_params.append(('jcr:content/transportPassword', params['jcrcontenttransport_password']))  # noqa: E501
        if 'jcrcontenttransport_uri' in params:
            query_params.append(('jcr:content/transportUri', params['jcrcontenttransport_uri']))  # noqa: E501
        if 'jcrcontenttransport_user' in params:
            query_params.append(('jcr:content/transportUser', params['jcrcontenttransport_user']))  # noqa: E501
        if 'jcrcontenttrigger_distribute' in params:
            query_params.append(('jcr:content/triggerDistribute', params['jcrcontenttrigger_distribute']))  # noqa: E501
        if 'jcrcontenttrigger_modified' in params:
            query_params.append(('jcr:content/triggerModified', params['jcrcontenttrigger_modified']))  # noqa: E501
        if 'jcrcontenttrigger_on_off_time' in params:
            query_params.append(('jcr:content/triggerOnOffTime', params['jcrcontenttrigger_on_off_time']))  # noqa: E501
        if 'jcrcontenttrigger_receive' in params:
            query_params.append(('jcr:content/triggerReceive', params['jcrcontenttrigger_receive']))  # noqa: E501
        if 'jcrcontenttrigger_specific' in params:
            query_params.append(('jcr:content/triggerSpecific', params['jcrcontenttrigger_specific']))  # noqa: E501
        if 'jcrcontentuser_id' in params:
            query_params.append(('jcr:content/userId', params['jcrcontentuser_id']))  # noqa: E501
        if 'jcrprimary_type' in params:
            query_params.append(('jcr:primaryType', params['jcrprimary_type']))  # noqa: E501
        if 'operation' in params:
            query_params.append((':operation', params['operation']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/agents.{runmode}/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_authorizables(self, authorizable_id, intermediate_path, **kwargs):  # noqa: E501
        """post_authorizables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_authorizables(authorizable_id, intermediate_path, async=True)
        >>> result = thread.get()

        :param async bool
        :param str authorizable_id: (required)
        :param str intermediate_path: (required)
        :param str create_user:
        :param str create_group:
        :param str reppassword:
        :param str profilegiven_name:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_authorizables_with_http_info(authorizable_id, intermediate_path, **kwargs)  # noqa: E501
        else:
            (data) = self.post_authorizables_with_http_info(authorizable_id, intermediate_path, **kwargs)  # noqa: E501
            return data

    def post_authorizables_with_http_info(self, authorizable_id, intermediate_path, **kwargs):  # noqa: E501
        """post_authorizables  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_authorizables_with_http_info(authorizable_id, intermediate_path, async=True)
        >>> result = thread.get()

        :param async bool
        :param str authorizable_id: (required)
        :param str intermediate_path: (required)
        :param str create_user:
        :param str create_group:
        :param str reppassword:
        :param str profilegiven_name:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorizable_id', 'intermediate_path', 'create_user', 'create_group', 'reppassword', 'profilegiven_name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_authorizables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in params or
                params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `post_authorizables`")  # noqa: E501
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in params or
                params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `post_authorizables`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'authorizable_id' in params:
            query_params.append(('authorizableId', params['authorizable_id']))  # noqa: E501
        if 'intermediate_path' in params:
            query_params.append(('intermediatePath', params['intermediate_path']))  # noqa: E501
        if 'create_user' in params:
            query_params.append(('createUser', params['create_user']))  # noqa: E501
        if 'create_group' in params:
            query_params.append(('createGroup', params['create_group']))  # noqa: E501
        if 'reppassword' in params:
            query_params.append(('rep:password', params['reppassword']))  # noqa: E501
        if 'profilegiven_name' in params:
            query_params.append(('profile/givenName', params['profilegiven_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/libs/granite/security/post/authorizables', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_felix_jetty_based_http_service(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_felix_jetty_based_http_service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_felix_jetty_based_http_service(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool org_apache_felix_https_nio:
        :param str org_apache_felix_https_nio_type_hint:
        :param str org_apache_felix_https_keystore:
        :param str org_apache_felix_https_keystore_type_hint:
        :param str org_apache_felix_https_keystore_password:
        :param str org_apache_felix_https_keystore_password_type_hint:
        :param str org_apache_felix_https_keystore_key:
        :param str org_apache_felix_https_keystore_key_type_hint:
        :param str org_apache_felix_https_keystore_key_password:
        :param str org_apache_felix_https_keystore_key_password_type_hint:
        :param str org_apache_felix_https_truststore:
        :param str org_apache_felix_https_truststore_type_hint:
        :param str org_apache_felix_https_truststore_password:
        :param str org_apache_felix_https_truststore_password_type_hint:
        :param str org_apache_felix_https_clientcertificate:
        :param str org_apache_felix_https_clientcertificate_type_hint:
        :param bool org_apache_felix_https_enable:
        :param str org_apache_felix_https_enable_type_hint:
        :param str org_osgi_service_http_port_secure:
        :param str org_osgi_service_http_port_secure_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_felix_jetty_based_http_service_with_http_info(runmode, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_felix_jetty_based_http_service_with_http_info(runmode, **kwargs)  # noqa: E501
            return data

    def post_config_apache_felix_jetty_based_http_service_with_http_info(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_felix_jetty_based_http_service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_felix_jetty_based_http_service_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool org_apache_felix_https_nio:
        :param str org_apache_felix_https_nio_type_hint:
        :param str org_apache_felix_https_keystore:
        :param str org_apache_felix_https_keystore_type_hint:
        :param str org_apache_felix_https_keystore_password:
        :param str org_apache_felix_https_keystore_password_type_hint:
        :param str org_apache_felix_https_keystore_key:
        :param str org_apache_felix_https_keystore_key_type_hint:
        :param str org_apache_felix_https_keystore_key_password:
        :param str org_apache_felix_https_keystore_key_password_type_hint:
        :param str org_apache_felix_https_truststore:
        :param str org_apache_felix_https_truststore_type_hint:
        :param str org_apache_felix_https_truststore_password:
        :param str org_apache_felix_https_truststore_password_type_hint:
        :param str org_apache_felix_https_clientcertificate:
        :param str org_apache_felix_https_clientcertificate_type_hint:
        :param bool org_apache_felix_https_enable:
        :param str org_apache_felix_https_enable_type_hint:
        :param str org_osgi_service_http_port_secure:
        :param str org_osgi_service_http_port_secure_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'org_apache_felix_https_nio', 'org_apache_felix_https_nio_type_hint', 'org_apache_felix_https_keystore', 'org_apache_felix_https_keystore_type_hint', 'org_apache_felix_https_keystore_password', 'org_apache_felix_https_keystore_password_type_hint', 'org_apache_felix_https_keystore_key', 'org_apache_felix_https_keystore_key_type_hint', 'org_apache_felix_https_keystore_key_password', 'org_apache_felix_https_keystore_key_password_type_hint', 'org_apache_felix_https_truststore', 'org_apache_felix_https_truststore_type_hint', 'org_apache_felix_https_truststore_password', 'org_apache_felix_https_truststore_password_type_hint', 'org_apache_felix_https_clientcertificate', 'org_apache_felix_https_clientcertificate_type_hint', 'org_apache_felix_https_enable', 'org_apache_felix_https_enable_type_hint', 'org_osgi_service_http_port_secure', 'org_osgi_service_http_port_secure_type_hint']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_felix_jetty_based_http_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_felix_jetty_based_http_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501

        query_params = []
        if 'org_apache_felix_https_nio' in params:
            query_params.append(('org.apache.felix.https.nio', params['org_apache_felix_https_nio']))  # noqa: E501
        if 'org_apache_felix_https_nio_type_hint' in params:
            query_params.append(('org.apache.felix.https.nio@TypeHint', params['org_apache_felix_https_nio_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore' in params:
            query_params.append(('org.apache.felix.https.keystore', params['org_apache_felix_https_keystore']))  # noqa: E501
        if 'org_apache_felix_https_keystore_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore@TypeHint', params['org_apache_felix_https_keystore_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore_password' in params:
            query_params.append(('org.apache.felix.https.keystore.password', params['org_apache_felix_https_keystore_password']))  # noqa: E501
        if 'org_apache_felix_https_keystore_password_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore.password@TypeHint', params['org_apache_felix_https_keystore_password_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key' in params:
            query_params.append(('org.apache.felix.https.keystore.key', params['org_apache_felix_https_keystore_key']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore.key@TypeHint', params['org_apache_felix_https_keystore_key_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key_password' in params:
            query_params.append(('org.apache.felix.https.keystore.key.password', params['org_apache_felix_https_keystore_key_password']))  # noqa: E501
        if 'org_apache_felix_https_keystore_key_password_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore.key.password@TypeHint', params['org_apache_felix_https_keystore_key_password_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_truststore' in params:
            query_params.append(('org.apache.felix.https.truststore', params['org_apache_felix_https_truststore']))  # noqa: E501
        if 'org_apache_felix_https_truststore_type_hint' in params:
            query_params.append(('org.apache.felix.https.truststore@TypeHint', params['org_apache_felix_https_truststore_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_truststore_password' in params:
            query_params.append(('org.apache.felix.https.truststore.password', params['org_apache_felix_https_truststore_password']))  # noqa: E501
        if 'org_apache_felix_https_truststore_password_type_hint' in params:
            query_params.append(('org.apache.felix.https.truststore.password@TypeHint', params['org_apache_felix_https_truststore_password_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_clientcertificate' in params:
            query_params.append(('org.apache.felix.https.clientcertificate', params['org_apache_felix_https_clientcertificate']))  # noqa: E501
        if 'org_apache_felix_https_clientcertificate_type_hint' in params:
            query_params.append(('org.apache.felix.https.clientcertificate@TypeHint', params['org_apache_felix_https_clientcertificate_type_hint']))  # noqa: E501
        if 'org_apache_felix_https_enable' in params:
            query_params.append(('org.apache.felix.https.enable', params['org_apache_felix_https_enable']))  # noqa: E501
        if 'org_apache_felix_https_enable_type_hint' in params:
            query_params.append(('org.apache.felix.https.enable@TypeHint', params['org_apache_felix_https_enable_type_hint']))  # noqa: E501
        if 'org_osgi_service_http_port_secure' in params:
            query_params.append(('org.osgi.service.http.port.secure', params['org_osgi_service_http_port_secure']))  # noqa: E501
        if 'org_osgi_service_http_port_secure_type_hint' in params:
            query_params.append(('org.osgi.service.http.port.secure@TypeHint', params['org_osgi_service_http_port_secure_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config.{runmode}/org.apache.felix.http', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_sling_dav_ex_servlet(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_sling_dav_ex_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_dav_ex_servlet(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str alias:
        :param str alias_type_hint:
        :param bool dav_create_absolute_uri:
        :param str dav_create_absolute_uri_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_sling_dav_ex_servlet_with_http_info(runmode, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_sling_dav_ex_servlet_with_http_info(runmode, **kwargs)  # noqa: E501
            return data

    def post_config_apache_sling_dav_ex_servlet_with_http_info(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_sling_dav_ex_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_dav_ex_servlet_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str alias:
        :param str alias_type_hint:
        :param bool dav_create_absolute_uri:
        :param str dav_create_absolute_uri_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'alias', 'alias_type_hint', 'dav_create_absolute_uri', 'dav_create_absolute_uri_type_hint']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_dav_ex_servlet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_sling_dav_ex_servlet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501

        query_params = []
        if 'alias' in params:
            query_params.append(('alias', params['alias']))  # noqa: E501
        if 'alias_type_hint' in params:
            query_params.append(('alias@TypeHint', params['alias_type_hint']))  # noqa: E501
        if 'dav_create_absolute_uri' in params:
            query_params.append(('dav.create-absolute-uri', params['dav_create_absolute_uri']))  # noqa: E501
        if 'dav_create_absolute_uri_type_hint' in params:
            query_params.append(('dav.create-absolute-uri@TypeHint', params['dav_create_absolute_uri_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config.{runmode}/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_sling_get_servlet(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_sling_get_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_get_servlet(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str json_maximumresults:
        :param str json_maximumresults_type_hint:
        :param bool enable_html:
        :param str enable_html_type_hint:
        :param bool enable_txt:
        :param str enable_txt_type_hint:
        :param bool enable_xml:
        :param str enable_xml_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_sling_get_servlet_with_http_info(runmode, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_sling_get_servlet_with_http_info(runmode, **kwargs)  # noqa: E501
            return data

    def post_config_apache_sling_get_servlet_with_http_info(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_sling_get_servlet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_get_servlet_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str json_maximumresults:
        :param str json_maximumresults_type_hint:
        :param bool enable_html:
        :param str enable_html_type_hint:
        :param bool enable_txt:
        :param str enable_txt_type_hint:
        :param bool enable_xml:
        :param str enable_xml_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'json_maximumresults', 'json_maximumresults_type_hint', 'enable_html', 'enable_html_type_hint', 'enable_txt', 'enable_txt_type_hint', 'enable_xml', 'enable_xml_type_hint']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_get_servlet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_sling_get_servlet`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501

        query_params = []
        if 'json_maximumresults' in params:
            query_params.append(('json.maximumresults', params['json_maximumresults']))  # noqa: E501
        if 'json_maximumresults_type_hint' in params:
            query_params.append(('json.maximumresults@TypeHint', params['json_maximumresults_type_hint']))  # noqa: E501
        if 'enable_html' in params:
            query_params.append(('enable.html', params['enable_html']))  # noqa: E501
        if 'enable_html_type_hint' in params:
            query_params.append(('enable.html@TypeHint', params['enable_html_type_hint']))  # noqa: E501
        if 'enable_txt' in params:
            query_params.append(('enable.txt', params['enable_txt']))  # noqa: E501
        if 'enable_txt_type_hint' in params:
            query_params.append(('enable.txt@TypeHint', params['enable_txt_type_hint']))  # noqa: E501
        if 'enable_xml' in params:
            query_params.append(('enable.xml', params['enable_xml']))  # noqa: E501
        if 'enable_xml_type_hint' in params:
            query_params.append(('enable.xml@TypeHint', params['enable_xml_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config.{runmode}/org.apache.sling.servlets.get.DefaultGetServlet', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_config_apache_sling_referrer_filter(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_sling_referrer_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_referrer_filter(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool allow_empty:
        :param str allow_empty_type_hint:
        :param str allow_hosts:
        :param str allow_hosts_type_hint:
        :param str allow_hosts_regexp:
        :param str allow_hosts_regexp_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_sling_referrer_filter_with_http_info(runmode, **kwargs)  # noqa: E501
        else:
            (data) = self.post_config_apache_sling_referrer_filter_with_http_info(runmode, **kwargs)  # noqa: E501
            return data

    def post_config_apache_sling_referrer_filter_with_http_info(self, runmode, **kwargs):  # noqa: E501
        """post_config_apache_sling_referrer_filter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_referrer_filter_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool allow_empty:
        :param str allow_empty_type_hint:
        :param str allow_hosts:
        :param str allow_hosts_type_hint:
        :param str allow_hosts_regexp:
        :param str allow_hosts_regexp_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'allow_empty', 'allow_empty_type_hint', 'allow_hosts', 'allow_hosts_type_hint', 'allow_hosts_regexp', 'allow_hosts_regexp_type_hint']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_referrer_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params or
                params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_sling_referrer_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']  # noqa: E501

        query_params = []
        if 'allow_empty' in params:
            query_params.append(('allow.empty', params['allow_empty']))  # noqa: E501
        if 'allow_empty_type_hint' in params:
            query_params.append(('allow.empty@TypeHint', params['allow_empty_type_hint']))  # noqa: E501
        if 'allow_hosts' in params:
            query_params.append(('allow.hosts', params['allow_hosts']))  # noqa: E501
        if 'allow_hosts_type_hint' in params:
            query_params.append(('allow.hosts@TypeHint', params['allow_hosts_type_hint']))  # noqa: E501
        if 'allow_hosts_regexp' in params:
            query_params.append(('allow.hosts.regexp', params['allow_hosts_regexp']))  # noqa: E501
        if 'allow_hosts_regexp_type_hint' in params:
            query_params.append(('allow.hosts.regexp@TypeHint', params['allow_hosts_regexp_type_hint']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/apps/system/config.{runmode}/org.apache.sling.security.impl.ReferrerFilter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_node_rw(self, path, name, **kwargs):  # noqa: E501
        """post_node_rw  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node_rw(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :param str add_members:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_node_rw_with_http_info(path, name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_node_rw_with_http_info(path, name, **kwargs)  # noqa: E501
            return data

    def post_node_rw_with_http_info(self, path, name, **kwargs):  # noqa: E501
        """post_node_rw  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node_rw_with_http_info(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :param str add_members:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'name', 'add_members']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node_rw" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_node_rw`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_node_rw`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'add_members' in params:
            query_params.append(('addMembers', params['add_members']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/{name}.rw.html', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_path(self, path, jcrprimary_type, name, **kwargs):  # noqa: E501
        """post_path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_path(path, jcrprimary_type, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str jcrprimary_type: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_path_with_http_info(path, jcrprimary_type, name, **kwargs)  # noqa: E501
        else:
            (data) = self.post_path_with_http_info(path, jcrprimary_type, name, **kwargs)  # noqa: E501
            return data

    def post_path_with_http_info(self, path, jcrprimary_type, name, **kwargs):  # noqa: E501
        """post_path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_path_with_http_info(path, jcrprimary_type, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str jcrprimary_type: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'jcrprimary_type', 'name']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_path`")  # noqa: E501
        # verify the required parameter 'jcrprimary_type' is set
        if ('jcrprimary_type' not in params or
                params['jcrprimary_type'] is None):
            raise ValueError("Missing the required parameter `jcrprimary_type` when calling `post_path`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_path`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501

        query_params = []
        if 'jcrprimary_type' in params:
            query_params.append(('jcr:primaryType', params['jcrprimary_type']))  # noqa: E501
        if 'name' in params:
            query_params.append((':name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/{path}/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_query(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """post_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_query(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
        else:
            (data) = self.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)  # noqa: E501
            return data

    def post_query_with_http_info(self, path, p_limit, _1_property, _1_property_value, **kwargs):  # noqa: E501
        """post_query  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'p_limit', '_1_property', '_1_property_value']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_query" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_query`")  # noqa: E501
        # verify the required parameter 'p_limit' is set
        if ('p_limit' not in params or
                params['p_limit'] is None):
            raise ValueError("Missing the required parameter `p_limit` when calling `post_query`")  # noqa: E501
        # verify the required parameter '_1_property' is set
        if ('_1_property' not in params or
                params['_1_property'] is None):
            raise ValueError("Missing the required parameter `_1_property` when calling `post_query`")  # noqa: E501
        # verify the required parameter '_1_property_value' is set
        if ('_1_property_value' not in params or
                params['_1_property_value'] is None):
            raise ValueError("Missing the required parameter `_1_property_value` when calling `post_query`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'p_limit' in params:
            query_params.append(('p.limit', params['p_limit']))  # noqa: E501
        if '_1_property' in params:
            query_params.append(('1_property', params['_1_property']))  # noqa: E501
        if '_1_property_value' in params:
            query_params.append(('1_property.value', params['_1_property_value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/bin/querybuilder.json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_tree_activation(self, ignoredeactivated, onlymodified, path, **kwargs):  # noqa: E501
        """post_tree_activation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_tree_activation(ignoredeactivated, onlymodified, path, async=True)
        >>> result = thread.get()

        :param async bool
        :param bool ignoredeactivated: (required)
        :param bool onlymodified: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, **kwargs)  # noqa: E501
        else:
            (data) = self.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, **kwargs)  # noqa: E501
            return data

    def post_tree_activation_with_http_info(self, ignoredeactivated, onlymodified, path, **kwargs):  # noqa: E501
        """post_tree_activation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, async=True)
        >>> result = thread.get()

        :param async bool
        :param bool ignoredeactivated: (required)
        :param bool onlymodified: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ignoredeactivated', 'onlymodified', 'path']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_tree_activation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ignoredeactivated' is set
        if ('ignoredeactivated' not in params or
                params['ignoredeactivated'] is None):
            raise ValueError("Missing the required parameter `ignoredeactivated` when calling `post_tree_activation`")  # noqa: E501
        # verify the required parameter 'onlymodified' is set
        if ('onlymodified' not in params or
                params['onlymodified'] is None):
            raise ValueError("Missing the required parameter `onlymodified` when calling `post_tree_activation`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_tree_activation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignoredeactivated' in params:
            query_params.append(('ignoredeactivated', params['ignoredeactivated']))  # noqa: E501
        if 'onlymodified' in params:
            query_params.append(('onlymodified', params['onlymodified']))  # noqa: E501
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['aemAuth']  # noqa: E501

        return self.api_client.call_api(
            '/etc/replication/treeactivation.html', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
