Metadata-Version: 2.0
Name: aioice
Version: 0.3.1
Summary: An implementation of Interactive Connectivity Establishment (RFC 5245)
Home-page: https://github.com/jlaine/aioice
Author: Jeremy Lain√©
Author-email: jeremy.laine@m4x.org
License: BSD
Description-Content-Type: UNKNOWN
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Web Environment
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Requires-Dist: netifaces

aioice
======

|rtd| |pypi-v| |pypi-pyversions| |pypi-l| |pypi-wheel| |travis| |coveralls|

.. |rtd| image:: https://readthedocs.org/projects/aioice/badge/?version=latest
   :target: https://aioice.readthedocs.io/

.. |pypi-v| image:: https://img.shields.io/pypi/v/aioice.svg
    :target: https://pypi.python.org/pypi/aioice

.. |pypi-pyversions| image:: https://img.shields.io/pypi/pyversions/aioice.svg
    :target: https://pypi.python.org/pypi/aioice

.. |pypi-l| image:: https://img.shields.io/pypi/l/aioice.svg
    :target: https://pypi.python.org/pypi/aioice

.. |pypi-wheel| image:: https://img.shields.io/pypi/wheel/aioice.svg
    :target: https://pypi.python.org/pypi/aioice

.. |travis| image:: https://img.shields.io/travis/jlaine/aioice.svg
    :target: https://travis-ci.org/jlaine/aioice

.. |coveralls| image:: https://img.shields.io/coveralls/jlaine/aioice.svg
    :target: https://coveralls.io/github/jlaine/aioice

What is ``aioice``?
-------------------

``aioice`` is a library for Interactive Connectivity Establishment (RFC 5245)
in Python. It is built on top of ``asyncio``, Python's standard asynchronous
I/O framework.

.. code:: python

    #!/usr/bin/env python

    import asyncio
    import aioice

    async def connect_using_ice():
        connection = aioice.Connection(ice_controlling=True)

        # gather local candidates
        local_candidates = await connection.get_local_candidates()

        # send your information to the remote party using your signaling method
        send_local_info(
            local_candidates,
            connection.local_username,
            connection.local_password)

        # receive remote information using your signaling method
        remote_candidates, remote_username, remote_password = get_remote_info()

        # perform ICE handshake
        connection.remote_candidates = remote_candidates
        connection.remote_username = remote_username
        connection.remote_password = remote_password
        await connection.connect()

        # send and receive data
        await connection.send(b'1234')
        data = await connection.recv()

        # close connection
        await connection.close()

    asyncio.get_event_loop().run_until_complete(connect_using_ice())


