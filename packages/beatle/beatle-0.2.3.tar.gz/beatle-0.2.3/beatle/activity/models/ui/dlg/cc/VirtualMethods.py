"""Subclass of VirtualMethods, which is generated by wxFormBuilder."""

import wx

from beatle import model
from beatle.lib import wxx
from beatle.activity.models.ui import ui as ui


# Implementing VirtualMethods
class VirtualMethodsDialog(ui.VirtualMethods):
    """
    This dialog allows to add inherited virtual methods.
    """
    @wxx.SetInfo(__doc__)
    def __init__(self, parent, container):
        "initialization"
        super(VirtualMethodsDialog, self).__init__(parent)
        # container es la clase destino
        self.container = container
        self.parent_class = container.inner_class
        # create a map of feasible casts
        self._classes = []
        self._methods = []
        for k in self.parent_class.inheritance:
            self.visit(k._ancestor)
        # scan the available virtual methods
        virtual = lambda x: x._virtual
        for cls in self._classes:
            members = lambda x: x.inner_class == cls
            self._methods.extend(filter(virtual,
                cls(model.cc.MemberMethod, members, True)))
        # create a map from method names to implementations
        self._map = {}
        members = lambda x: x.inner_class == self.parent_class
        for k in self._methods:
            s = k.label.replace('=0', '')
            override = lambda x: x._virtual and x.label == s
            if s not in self._map:
                #find the method inside the class
                self._map[s] = (k,
                    filter(override, self.parent_class(model.cc.MemberMethod,
                        members, True)))
        # ok, do insertion remebering implementations
        pos = 0
        for k in self._map:
            v = self._map[k]
            self.m_checkList2.Insert(k, pos, v)
            if v[1]:
                self.m_checkList2.Check(pos)
            pos = pos + 1
        aTable = wx.AcceleratorTable([
            wx.AcceleratorEntry(wx.ACCEL_NORMAL, wx.WXK_RETURN, wx.ID_OK),
        #tree navigation facilities
        ])
        self.SetAcceleratorTable(aTable)

    def visit(self, k):
        """Add ancestor branch"""
        for l in k.inheritance:
            self.visit(l._ancestor)
        self._classes.append(k)

    def get_kwargs(self):
        """Returns kwargs dictionary suitable for objects creation"""
        kwargs_list = []
        for item in range(0, self.m_checkList2.GetCount()):
            v = self.m_checkList2.GetClientData(item)
            c = self.m_checkList2.IsChecked(item)
            if  (c and v[1]) or (not c and not v[1]):
                continue
            if c:
                kwargs = {}
                kwargs = v[0].get_kwargs()
                kwargs['parent'] = self.container
                kwargs['pure'] = False
                kwargs['declare'] = True
                kwargs['implement'] = True
                kwargs_list.append(kwargs)
            else:
                for m in v[1]:
                    m.Delete()
        return kwargs_list
