"""Subclass of FilePane, which is generated by wxFormBuilder."""

import wx.stc

from beatle import tran
from beatle.ctx import THE_CONTEXT as context
from beatle.tran import TransactionStack as stack
from beatle.app.ui.pane import BasePane
from beatle.lib.handlers import IdentifiersHandler
from beatle.activity.arch.ui import ui as ui
from beatle.activity.arch.handlers.cpp import EditorHandler

# Implementing FilePane
class FilePane(BasePane, ui.FilePane):
    """Implements code editor"""

    _toggleFull = IdentifiersHandler.register('fullscreen')
    _closePane  = IdentifiersHandler.register('close-pane')
    _save = IdentifiersHandler.register("ID_SAVE_PROJECT")
    _delete = IdentifiersHandler.register("ID_DELETE")

    def __init__(self, parent, mainframe, fileobj):
        """Intialization of method editor"""
        self._parent = parent
        self._mainframe = mainframe
        self._object = fileobj
        self._types = dict([(x._name, x) for x in fileobj.project.types])
        if '@' in self._types:
            del self._types['@']
        keywords2 = [x for x in self._types.keys() if x and x not in ['unsigned', 'long']] + ['unsigned long']
        self._editorArgs = {
            'language': 'c++',
            'handler': EditorHandler(
                obj=fileobj,
                keywords2=keywords2
            )
        }
        super(FilePane, self).__init__(parent)
        self._defaulBkColor = self.GetBackgroundColour()
        self.Layout()
        wx.stc.EVT_STC_CHANGE(self.m_editor, self.m_editor.GetId(),
            self.OnEditorChange)
        frame = context.frame
        self._fullScreen = None
        self.Bind(wx.EVT_MENU, handler=frame.CloseCurrentDocPane, id=self._closePane)
        self.BindSpecial(wx.EVT_MENU, handler=self.OnDelete, id=self._delete)
        self.BindSpecial(wx.EVT_MENU, handler=self.OnSave, id=self._save)
        self.BindSpecial(wx.EVT_UPDATE_UI, handler=self.OnUpdateSave, id=self._save)
        aTable = wx.AcceleratorTable([
            wx.AcceleratorEntry(wx.ACCEL_NORMAL, wx.WXK_DELETE, self._delete),
            wx.AcceleratorEntry(wx.ACCEL_ALT | wx.ACCEL_CTRL, ord('F'), self._toggleFull),
            wx.AcceleratorEntry(wx.ACCEL_CTRL, ord('W'), self._closePane),
            wx.AcceleratorEntry(wx.ACCEL_CTRL, ord('S'), self._save)
        ])
        self.SetAcceleratorTable(aTable)

    def Refresh(self):
        """Update editor from external changes (like undo/redo)"""
        if not self.m_editor.IsModified():
            try:
                oldText = self.m_editor.GetText()
                newText = self._object.GetText()
                if oldText == newText:
                    return
            except:
                return
            self.m_editor.Freeze()
            try:
                line = self.m_editor.GetFirstVisibleLine()
                pos = self.m_editor.GetCurrentPos()
                self.m_editor.SetText(newText)
                self.m_editor.SetModified(False)
                self.m_editor.SetFirstVisibleLine(line)
                self.m_editor.SetCurrentPos(pos)
            except:
                pass
            self.m_editor.Thaw()
            self.m_editor.SetModified(False)

    def UpdateModifiedTitle(self):
        """Update the tile after modifications"""
        if not self._fullScreen:
            i = self._parent.GetPageIndex(self)
            if i < 0:
                print "Alert: modified editor not booked"
                return
            s = self._parent.GetPageText(i)
            m = '[modified] '
            if self.m_editor.IsModified():
                if s.find(m) == wx.NOT_FOUND:
                    self._parent.SetPageText(i, m + s)
            else:
                if s.find(m) != wx.NOT_FOUND:
                    s = s.replace(m, '')
                    self._parent.SetPageText(i, s)


    def OnEditorChange(self, event):
        """Called when editor status change"""
        if not self._fullScreen:
            self.UpdateModifiedTitle()

    def OnUpdateSave(self, event):
        """Handles update event"""
        event.Enable(self.m_editor.IsModified())

    def OnSave(self, event):
        """Handles save event"""
        self.Commit()
        self.m_editor.ResetModified()
        self.UpdateModifiedTitle()

    def OnGetFocus(self, event):
        """Handle GetFocus event"""
        event.Skip()  # This ensures editor cursor handling
        super(FilePane, self).OnGetFocus(event)

    def OnKillFocus(self, event):
        """Handle kill focus event"""
        event.Skip()  # This ensures editor cursor handling
        super(FilePane, self).OnKillFocus(event)

    def GotoLine(self, line, select=False):
        """Called for goto to line"""
        self.m_editor.GotoLine(line, select)

    @tran.TransactionalMethod()
    def Commit(self):
        """Do commit changes"""
        if self.m_editor.GetModify():
            self._object.SaveState()
            self._object.SetText(self.m_editor.GetText())
            self.m_editor.SetModified(False)
            stack.instance.SetName('modify file {0}'.format(self._object._name))
            return True
        else:
            return False

    @property
    def breakpoint(self):
        """return info about if the current line holds breakpoint"""
        return self.m_editor.breakpoint

    def ToggleBreakpoint(self, event):
        """toggle breakpoint"""
        self.m_editor.ToggleBreakpoint(event)

    @property
    def line(self):
        """return current line"""
        return self.m_editor.GetCurrentLine()

    def OnDelete(self, event):
        """Handle delete key"""
        (b, e) = self.m_editor.GetSelection()
        if b == e:
            self.m_editor.CharRight()
        self.m_editor.DeleteBack()



