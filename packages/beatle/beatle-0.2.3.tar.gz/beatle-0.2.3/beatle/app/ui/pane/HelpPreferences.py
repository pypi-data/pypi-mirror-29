"""Subclass of HelpPreferences, which is generated by wxFormBuilder."""
import wx

from beatle.app.ui import dlg
from beatle.app import HelpPreferences as base
from beatle.ctx import THE_CONTEXT as context

# Implementing HelpPreferences
class HelpPreferences(base):
	def __init__( self, parent ):
		super(HelpPreferences, self).__init__(parent)
		# adjust controls
		sz = self.m_help_items.GetClientSize()
		self.m_help_items.InsertColumn(0, '', wx.LIST_FORMAT_LEFT, sz.x)
		self._changes = False
		self.UpdateData()
		
	def ReadConfig(self):
		"""Read config"""
		self._entry = {}
		self._order = {}
		items = context.config.ReadInt("config/help/items", 3)
		if items >= 1:
			label = context.config.Read("config/help/item/1/label", "cpp reference ...")
			url = context.config.Read("config/help/item/1/url", "http://en.cppreference.com")
			descr = context.config.Read("config/help/item/1/descr", "check online c++ reference")			
			self._entry[label] = (url, descr)
			self._order[1] = label
		if items >= 2:
			label = context.config.Read("config/help/item/2/label", "python 2 reference ...")
			url = context.config.Read("config/help/item/2/url", "https://docs.python.org/2/")
			descr = context.config.Read("config/help/item/2/descr", "check python online reference")			
			self._entry[label] = (url, descr)
			self._order[2] = label
		if items >= 3:
			label = context.config.Read("config/help/item/3/label", "python digger")
			url = context.config.Read("config/help/item/3/url", "http://pydigger.com")
			descr = context.config.Read("config/help/item/3/descr", "")			
			self._entry[label] = (url, descr)
			self._order[3] = label
		#if items >= 4:
		#	 label = context.config.Read("config/help/item/3/label", "online tutorials")
		#	 url = context.config.Read("config/help/item/3/url", "cpp reference ...")
		for index in range(4, items+1):
			label = context.config.Read("config/help/item/{0}/label".format(index), '')
			url = context.config.Read("config/help/item/{0}/url".format(index), '')
			descr = context.config.Read("config/help/item/{0}/descr".format(index), "")			
			if label and url:
				self._entry[label] = (url, descr)
				self._order[index] = label
				
	def SaveConfig(self):
		"""Save config"""
		items = len(self._entry)
		context.config.WriteInt("config/help/items",items)
		for index in range(1, items+1):
			key = self._order[index]
			value, descr = self._entry[key]
			context.config.Write("config/help/item/{0}/label".format(index), key)
			context.config.Write("config/help/item/{0}/url".format(index), value)
			context.config.Write("config/help/item/{0}/descr".format(index), descr)
				
	def UpdateData(self):
		"""Update help preferences data"""
		self.ReadConfig()
		self.m_help_items.DeleteAllItems()
		items = len(self._entry)
		for index in range(1, items+1):
			key = self._order[index]
			#descr = self._entry[key][1]
			self.m_help_items.Append((key,))	
			
	def SaveData(self):		
		"""Save information"""
		if self._changes:
			self.SaveConfig()
			context.frame.BuildHelpMenu()
		
	# Handlers for HelpPreferences events.
	def OnSelectItem( self, event ):
		self.m_edit_btn.Enable(True)
		self.m_del_btn.Enable(True)
		
	def OnDeselectItem(self, event):
		self.m_edit_btn.Enable(False)
		self.m_del_btn.Enable(False)
	
	def OnNewItem( self, event ):
		_dlg = dlg.HelpItem(self)
		index = len(self._entry)+1
		if _dlg.ShowModal() == wx.ID_OK:
			new_key = _dlg._label
			new_url = _dlg._url
			new_descr = _dlg._help
			if new_key in self._entry:
				#alert key already exists
				choice = wx.MessageBox( "The item {0} already exists.\nOwerwrite?".format(new_key),
					"Warning", wx.YES_NO | wx.ICON_INFORMATION, self)
				if choice is not wx.YES:
					return
				index = dict([(y,x) for (x,y) in self._order])[new_key]				
			else:
				self.m_help_items.Append((new_key,))	
			self._changes = True
			self._entry[new_key] = (new_url,new_descr)
			self._order[index] = new_key 
			
	def OnEnterItem(self, event):
		self.OnEditItem(event)
	
	def OnEditItem( self, event ):
		# TODO: Implement OnEditItem
		index = self.m_help_items.GetFirstSelected()
		if index is wx.NOT_FOUND:
			return
		key = self.m_help_items.GetItemText(index)
		if key not in self._entry:
			return
		url, descr = self._entry[key]
		_dlg = dlg.HelpItem(self)
		_dlg.SetAttributes(key, url, descr)
		if _dlg.ShowModal() == wx.ID_OK:
			new_key = _dlg._label
			new_url = _dlg._url
			new_descr = _dlg._help
			if new_key != key:
				self._changes = True
				del self._entry[key]
				self.m_help_items.SetItemText(index, new_key)
				self._entry[new_key] = (new_url, new_descr)
				self._order[index+1] = new_key
			elif new_url != url or new_descr != descr:
				self._changes = True
				self._entry[new_key] = (new_url, new_descr)
	
	def OnDeleteItem( self, event ):
		index = self.m_help_items.GetFirstSelected()
		if index is not wx.NOT_FOUND:
			key = self.m_help_items.GetItemText(index)
			if key in self._entry:
				index = index + 1
				del self._entry[key]
				del self._order[index]
				index = index + 1
				for k in range(index, len(self._entry)+2): 
					self._order[k] = k -1
				self._changes = True
			self.m_help_items.DeleteItem(index)
		self.m_edit_btn.Enable(False)
		self.m_del_btn.Enable(False)
		
	
	
	
