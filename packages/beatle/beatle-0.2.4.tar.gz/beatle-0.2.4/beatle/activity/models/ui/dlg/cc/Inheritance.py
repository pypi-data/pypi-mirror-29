"""Subclass of NewInheritance, which is generated by wxFormBuilder."""

import wx

from beatle import model
from beatle.app import resources
from beatle.lib import wxx
from beatle.activity.models.ui import ui


# Implementing NewInheritance
class InheritanceDialog(ui.NewInheritance):
    """
    This dialog allows to setup inheritance from
    another struct or class.
    """
    @wxx.SetInfo(__doc__)
    def __init__(self, parent, container):
        """Initialize dialog"""
        super(InheritanceDialog, self).__init__(parent)
        self._name = ""
        self._original = ""
        self._element = container
        self.project = container.project
        self.__initClassBoxes__()
        self.m_choice11.SetFocus()
        icon = wx.EmptyIcon()
        icon.CopyFromBitmap(resources.GetBitmap("inheritance"))
        self.SetIcon(icon)

    def __initClassBoxes__(self):
        """Initialize class boxes"""
        classes = self.project.level_classes
        scoped = lambda x: (hasattr(x, 'scoped') and x.scoped) or x.name
        for clase in classes:
            if self._element == clase:
                continue
            if self._element.IsAncestor(clase):
                continue
            self.m_choice11.Append(scoped(clase), clase)
        if len(classes) > 0:
            self.m_choice11.SetSelection(0)

    def Validate(self):
        """Validation"""
        iSel = self.m_choice11.GetCurrentSelection()
        if iSel == wx.NOT_FOUND:
            wx.MessageBox("Inheritance requires selecting base class", "Error",
                wx.OK | wx.CENTER | wx.ICON_ERROR, self)
            return False
        self._name = self.m_choice11.GetString(iSel)
        self._ancestor = self.m_choice11.GetClientData(iSel)
        iSel = self.m_choice12.GetCurrentSelection()
        if iSel == wx.NOT_FOUND:
            wx.MessageBox("Inheritance requires access", "Error",
                wx.OK | wx.CENTER | wx.ICON_ERROR, self)
            return False
        self._access = self.m_choice12.GetString(iSel)
        self._virtual = self.m_checkBox51.IsChecked()
        self._note = self.m_richText3.GetValue()
        if self._name != self._original:
            inheritance = self._element(model.cc.Inheritance,
                filter=lambda x: x.inner_class == self._element, cut=True)
            if self._name in [x._name for x in inheritance]:
                wx.MessageBox("Inheritance from " + self._name +
                " already exists", "Error",
                    wx.OK | wx.CENTER | wx.ICON_ERROR, self)
                return False
        return True

    def CopyAttributes(self, inheritance):
        """Copy attributes to inheritance"""
        inheritance._name = self._name
        inheritance.SetAncestor(self._ancestor)
        inheritance._access = self._access
        inheritance._virtual = self._virtual
        inheritance.note = self._note

    def SetAttributes(self, inheritance):
        """Setup attributes for editing already inheritance"""
        scoped = lambda x: (hasattr(x, 'scoped') and x.scoped) or x.name
        self._original = scoped(inheritance._ancestor)
        iSel = self.m_choice11.FindString(self._original)
        self.m_choice11.SetSelection(iSel)
        iSel = self.m_choice12.FindString(inheritance._access)
        self.m_choice12.SetSelection(iSel)
        self.m_checkBox51.SetValue(inheritance._virtual)
        self.m_richText3.SetValue(inheritance.note)
        self.SetTitle("Edit inheritance")

    def get_kwargs(self):
        """returns arguments suitable for object instance"""
        return {'parent': self._element, 'ancestor': self._ancestor,
            'access': self._access, 'virtual': self._virtual,
            'note': self._note}

    # Handlers for NewMethod events.
    def OnCancel(self, event):
        """cancel event handler"""
        self.EndModal(wx.ID_CANCEL)

    # Handlers for NewInheritance events.
    def OnOK(self, event):
        """Process OnOk event"""
        """ok event handler"""
        if self.Validate():
            self.EndModal(wx.ID_OK)


