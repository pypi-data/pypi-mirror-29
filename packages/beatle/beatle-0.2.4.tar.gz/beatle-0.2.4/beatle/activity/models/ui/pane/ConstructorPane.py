# -*- coding: utf-8 -*-
"""Subclass of ConstructorPane, which is generated by wxFormBuilder."""

#import wx


import wx.stc
import wx.lib.newevent

import beatle
from beatle.ctx import THE_CONTEXT as context
from beatle import tran, localpath
from beatle.lib.handlers import Identifiers
from beatle.app.ui.pane import BasePane
from beatle.activity.models.ui import ui as ui
from beatle.activity.models.handlers.cpp import EditorHandler
from beatle.activity.models.ui.dlg.cc import NavigatorDialog
from beatle.analytic.cppparse import gather_vars

MARGIN_LINE_NUMBERS = 0
MARGIN_FOLD = 1


#define update sash required event
UglySashEvent, EVT_UGLY_SASH = wx.lib.newevent.NewEvent()

LocalCommand, EVT_LOCAL_COMMAND_EVENT = wx.lib.newevent.NewCommandEvent()


# Implementing ConstructorPane
class ConstructorPane(BasePane,ui.ConstructorPane):
    """Pane for constructor edition"""
    # command ids:
    _delete = Identifiers.register("ID_DELETE")
    _undo  = Identifiers.register("ID_UNDO")
    _redo  = Identifiers.register("ID_REDO")
    _copy  = Identifiers.register("ID_COPY")
    _cut  = Identifiers.register("ID_CUT")
    _paste  = Identifiers.register("ID_PASTE")
    _save  = Identifiers.register("ID_SAVE")

    _closePane  = Identifiers.register('close-pane')
    _toggleFull = Identifiers.register('fullscreen')
    _navigator = Identifiers.new()

    def _create_toolbars(self):
        """Create custom toolbar"""
        self.m_localToolbar = wx.aui.AuiToolBar(self, wx.ID_ANY, wx.DefaultPosition,
            wx.DefaultSize, wx.aui.AUI_TB_HORZ_LAYOUT)
        self.m_save = self.m_localToolbar.AddTool(self._save,
            u"save code", wx.ArtProvider.GetBitmap(wx.ART_FILE_SAVE, wx.ART_TOOLBAR),
            wx.NullBitmap, wx.ITEM_NORMAL, u"Save", wx.EmptyString, None)
        self.m_localToolbar.AddSeparator()
        self.m_undo = self.m_localToolbar.AddTool(self._undo, u"tool",
            wx.ArtProvider.GetBitmap(wx.ART_UNDO, wx.ART_TOOLBAR), wx.NullBitmap, wx.ITEM_NORMAL,
            u"Undo", wx.EmptyString, None)
        self.m_redo = self.m_localToolbar.AddTool(self._redo, u"tool",
            wx.ArtProvider.GetBitmap(wx.ART_REDO, wx.ART_TOOLBAR), wx.NullBitmap, wx.ITEM_NORMAL,
            u"Redo", wx.EmptyString, None)
        self.m_localToolbar.AddSeparator()
        self.m_copy = self.m_localToolbar.AddTool(self._copy, u"copy",
            wx.ArtProvider.GetBitmap(wx.ART_COPY, wx.ART_TOOLBAR), wx.NullBitmap, wx.ITEM_NORMAL,
            u"Copy", wx.EmptyString, None)
        self.m_cut = self.m_localToolbar.AddTool(self._cut, u"cut", wx.ArtProvider.GetBitmap(
            wx.ART_CUT, wx.ART_TOOLBAR), wx.NullBitmap, wx.ITEM_NORMAL, u"Cut", wx.EmptyString, None)
        self.m_paste = self.m_localToolbar.AddTool(self._paste, u"paste",
            wx.ArtProvider.GetBitmap(wx.ART_PASTE, wx.ART_TOOLBAR), wx.NullBitmap,
            wx.ITEM_NORMAL, u"Paste", wx.EmptyString, None)
        self.m_localToolbar.AddSeparator()
        self.m_delete = self.m_localToolbar.AddTool(self._delete, u"delete",
            wx.ArtProvider.GetBitmap(wx.ART_DELETE, wx.ART_TOOLBAR), wx.NullBitmap, wx.ITEM_NORMAL,
            u"Delete", wx.EmptyString, None)
        self.m_localToolbar.AddSeparator()
        self.m_fullScreen = self.m_localToolbar.AddTool(self._toggleFull, u"tool",
            wx.ArtProvider.GetBitmap(u"gtk-fullscreen", wx.ART_TOOLBAR), wx.NullBitmap, wx.ITEM_NORMAL,
            u"Toggle fullscreen", wx.EmptyString, None)
        self.m_localToolbar.AddSeparator()
        self.m_navigator = self.m_localToolbar.AddTool(self._navigator, u"tool", wx.Bitmap(localpath("app/res/method.xpm"),
            wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, u"insert call", wx.EmptyString, None)
        self.m_localToolbar.Realize()
        self.m_toolbarSizer.Add(self.m_localToolbar, 0, wx.ALL, 5)
        self.Layout()

    def __init__(self, parent, mainframe, constructor):
        """Initialization"""
        self._mainframe = mainframe
        self._object = constructor
        self._notebook = parent
        container = constructor.inner_member_container
        container_cls = container.inner_class
        if container_cls:
            s = [container_cls.scoped]
            scoped = lambda x: (hasattr(x, 'scoped_str') and x.scoped_str(s)
            ) or (hasattr(x, 'scoped') and x.scoped) or x.name
            self._types = dict([scoped(x), x] for x in container.types)
        else:
            self._types = dict([scoped(x), x] for x in container.types)
            scoped = lambda x: (hasattr(x, 'scoped') and x.scoped) or x.name
            self._types = dict([scoped(x), x] for x in container.types)

        if '@' in self._types:
            del self._types['@']
        keywords2 = [x for x in self._types.keys() if x and x not in ['unsigned', 'long']] + ['unsigned long']
        self._editorArgsInit = {
            'language': 'c++',
            'style' : wx.VSCROLL,
            'handler': EditorHandler(
                text=constructor._init,
                read_only=constructor._readOnly,
                use_bookmarks=False,
                use_breakpoints=False,
                keywords2=keywords2
            )
        }
        self._editorArgs = {
            'language': 'c++',
            'handler': EditorHandler(
                text=constructor._content,
                read_only=constructor._readOnly,
                use_bookmarks=True,
                use_breakpoints=False,
                keywords2=keywords2
            )
        }
        super(ConstructorPane, self).__init__(parent)
        self._bodyTouched = False

        #self.m_editor.SetText(constructor._content)
        #self.m_init.SetText(constructor._init)
        #self.m_editor.Initialize(self._types)
        #self.m_init.Initialize(self._types)
        self.RecalcSashPos()
        self.Layout()
        self._create_toolbars()

        frame = context.frame
        #bind some messages to this frame
        self.BindSpecial(wx.EVT_MENU, frame.CloseCurrentDocPane, id=self._closePane)
        self.BindSpecial(wx.EVT_MENU, self.OnDeleteCode, id=self._delete)
        self.BindSpecial(wx.EVT_MENU, self.OnUndoCode, id=self._undo)
        self.BindSpecial(wx.EVT_MENU, self.OnRedoCode, id=self._redo)
        self.BindSpecial(wx.EVT_MENU, self.OnCopyCode, id=self._copy)
        self.BindSpecial(wx.EVT_MENU, self.OnPasteCode, id=self._paste)
        self.BindSpecial(wx.EVT_MENU, self.OnCutCode, id=self._cut)
        self.BindSpecial(wx.EVT_MENU, self.OnSaveCode, id=self._save)
        self.BindSpecial(wx.EVT_MENU, self.OnFullScreen, id=self._toggleFull)

        self.BindSpecial(wx.EVT_UPDATE_UI, self.OnUpdateDeleteCode, id=self._delete)
        self.BindSpecial(wx.EVT_UPDATE_UI, self.OnUpdateUndoCode, id=self._undo)
        self.BindSpecial(wx.EVT_UPDATE_UI, self.OnUpdateRedoCode, id=self._redo)
        self.BindSpecial(wx.EVT_UPDATE_UI, self.OnUpdateCopyCode, id=self._copy)
        self.BindSpecial(wx.EVT_UPDATE_UI, self.OnUpdatePasteCode, id=self._paste)
        self.BindSpecial(wx.EVT_UPDATE_UI, self.OnUpdateCutCode, id=self._cut)
        self.BindSpecial(wx.EVT_UPDATE_UI, self.OnUpdateSaveCode, id=self._save)

        self._selected = None
        self.m_editor.popup_handler = self
        self.m_init.popup_handler = self
        self._fullScreen = None

        wx.stc.EVT_STC_CHANGE(self.m_editor, self.m_editor.GetId(),
             self.OnEditorChange)
        wx.stc.EVT_STC_CHANGE(self.m_init, self.m_init.GetId(), self.OnInitChange)

        wx.stc.EVT_STC_ZOOM(self.m_editor, self.m_editor.GetId(),
            self.OnEditorZoomed)
        wx.stc.EVT_STC_ZOOM(self.m_init, self.m_init.GetId(),
            self.OnInitZoomed)

        EVT_UGLY_SASH(self, self.OnUglySash)

        aTable = wx.AcceleratorTable([
            wx.AcceleratorEntry(wx.ACCEL_ALT | wx.ACCEL_CTRL, ord('F'), self._toggleFull),
            wx.AcceleratorEntry(wx.ACCEL_CTRL, ord('W'), self._closePane),
            wx.AcceleratorEntry(wx.ACCEL_CTRL, ord('S'), self._save),
            wx.AcceleratorEntry(wx.ACCEL_NORMAL, wx.WXK_DELETE, self._delete)
        ])
        self.SetAcceleratorTable(aTable)

    def Refresh(self):
        """Update editor from external changes (like undo/redo)"""
        if not self.m_init.IsModified() and not self.m_editor.IsModified():
            if self.m_init.GetText() != self._object._init:
                line = self.m_init.GetFirstVisibleLine()
                pos = self.m_init.GetCurrentPos()
                self.m_init.Freeze()
                self.m_init.SetText(self._object._init)
                try:
                    self.m_init.SetFirstVisibleLine(line)
                    self.m_init.SetCurrentPos(pos)
                except:
                    pass
                self.m_init.Thaw()
                wx.YieldIfNeeded()
                self.m_init.SetModified(False)
            if self.m_editor.GetText() != self._object._content:
                line = self.m_editor.GetFirstVisibleLine()
                pos = self.m_editor.GetCurrentPos()
                self.m_editor.Freeze()
                self.m_editor.SetText(self._object._content)
                try:
                    self.m_editor.SetFirstVisibleLine(line)
                    self.m_editor.SetCurrentPos(pos)
                except:
                    pass
                self.m_editor.Thaw()
                wx.YieldIfNeeded()
                self.m_editor.SetModified(False)

    def PreDelete(self):
        """Remove toolbar first in order to avoid gtk-collision at close"""
        #self.m_editor.Destroy()
        #self.m_init.Destroy()
        self.m_localToolbar.Destroy()
        super(ConstructorPane, self).PreDelete()

    def Popup(self, editor, text=None):
        """Called from editor to show user menus"""
        from beatle.model import cc
        if editor is not self.m_editor:
            return
        pos = editor.GetCurrentPos()
        code = editor.GetText()[:pos]
        _vars = gather_vars(code, self._types)
        if type(_vars) is not dict:
            return
        _class = self._object.inner_class
        if _class is not None:
            _vars.update({"this": {
                'type': _class,
                'static': False,
                'volatile': False,
                'const': False,
                'register': False,
                'ptr': True,
                'ref': False,
                'array': False
            }})
        if not _vars:
            return
        if text:
            if text not in _vars:
                return
            var = _vars[text]
            _type = var['type']
            if type(_type) is cc.Class:
                pos = editor.GetCurrentPos()
                p = editor.PointFromPosition(pos)
                p = editor.ClientToScreen(p)
                dlg = NavigatorDialog(editor, p, _type=_type)
                if not dlg.empty and dlg.ShowModal() == wx.ID_OK:
                    editor.AddText(dlg.value+";\n")
                    editor.AutoIndent(True)
            return
        else:
            pos = editor.GetCurrentPos()
            p = editor.PointFromPosition(pos)
            p = editor.ClientToScreen(p)
            dlg = NavigatorDialog(editor, p, _vars=_vars)
            if not dlg.empty and dlg.ShowModal() == wx.ID_OK:
                editor.AddText(dlg.value+";\n")
                editor.AutoIndent(True)

    def OnInitPane(self):
        """Initialization"""
        self.RecalcSashPos()

    def RecalcSashPos(self):
        """Take amodelount of init section and recalc sash"""
        h = 10
        if self.m_init.GetLineCount():
            h += (self.m_init.GetLineCount() + 1) * (self.m_init.TextHeight(0) +
                self.m_init.GetExtraAscent() +
                self.m_init.GetExtraDescent())
        #self.m_splitter2.SetMinimumPaneSize(h)
        self.m_splitter2.SetSashPosition(h, True)
        self.Layout()
        self.m_splitter2.UpdateSize()

    def Disabled(self, event):
        """Joker event"""
        event.Enable(False)

    def UpdateModifiedTitle(self):
        """Update the tile after modifications"""
        if not self._fullScreen:
            i = self._notebook.GetPageIndex(self)
            s = self._notebook.GetPageText(i)
            m = '[modified] '
            if self.m_editor.IsModified() or self.m_init.IsModified():
                if s[:11] != m:
                    self._notebook.SetPageText(i, m + s)
            else:
                if s[:11] == m:
                    self._notebook.SetPageText(i, s[11:])

    def OnEditorChange(self, event):
        """Called when editor status change"""
        self.UpdateModifiedTitle()

    def OnInitChange(self, event):
        """Called when editor status change"""
        self.RecalcSashPos()
        self.UpdateModifiedTitle()

    def OnUglySash(self, event):
        """Recalc sash"""
        sz = event.source.GetZoom()
        tz = event.target.GetZoom()
        if sz != tz:
            event.target.SetZoom(sz)
            wx.PostEvent(self, event)
        else:
            self.RecalcSashPos()

    def OnEditorZoomed(self, event):
        """Called when the UI of the editor changes"""
        e = UglySashEvent(source=self.m_editor, target=self.m_init)
        wx.PostEvent(self, e)
        event.Skip()

    def OnInitZoomed(self, event):
        """Called when the UI of the init par changes"""
        e = UglySashEvent(source=self.m_init, target=self.m_editor)
        wx.PostEvent(self, e)
        event.Skip()

    @tran.TransactionalMethod('edit constructor')
    def Commit(self):
        """Update document"""
        text = self.m_editor.GetText()
        init = self.m_init.GetText()
        o = self._object
        if text == o._content and init == o._init:
            return False
        if text != o._content:
            o._bodyTouched = True
        if init != o._content:
            o._initTouched = True
        o.SaveState()
        o._content = text
        o._init = init
        o.project.SetModified(True)
        k = o.outer_class or o.outer_module
        if k:
            k.ExportCppCodeFiles(force=True)
        return True

    def OnUndoCode(self, event):
        """Edit undo"""
        if self._selected:
            self._selected.Undo()

    def OnRedoCode(self, event):
        """Edit redo"""
        if self._selected:
            self._selected.Redo()

    def OnUpdateUndoCode(self, event):
        """Edit undo?"""
        if self._selected and self._selected.CanUndo():
            event.SetText("Undo edit")
            event.Enable(True)
        else:
            event.SetText("Can't undo")
            event.Enable(False)

    def OnUpdateRedoCode(self, event):
        """Edit redo?"""
        if self._selected and self._selected.CanRedo():
            event.SetText("Redo edit")
            event.Enable(True)
        else:
            event.SetText("Can't redo")
            event.Enable(False)

    def OnUpdateCopyCode(self, event):
        """Edit copy?"""
        if self._selected:
            (b, e) = self._selected.GetSelection()
            event.Enable(b != e)
        else:
            event.Enable(False)

    def OnUpdatePasteCode(self, event):
        """Edit paste?"""
        event.Enable(bool(self._selected and self._selected.CanPaste()))

    def OnUpdateCutCode(self, event):
        """Edit paste?"""
        """Edit cut?"""
        if self._object._readOnly or not self._selected:
            event.Enable(False)
        else:
            (b, e) = self._selected.GetSelection()
            event.Enable(b != e)

    def OnUpdateDeleteCode(self, event):
        """Edit delete?"""
        event.Enable(not self._object._readOnly)

    def OnUpdateSaveCode(self, event):
        """Handles update event"""
        event.Enable(self.m_editor.IsModified() or self.m_init.IsModified())

    def OnDeleteCode(self, event):
        """Handle delete for focus editor"""
        if self._selected is None:
            return
        (b, e) = self._selected.GetSelection()
        if b == e:
            self._selected.CharRight()
        self._selected.DeleteBack()

    def OnCopyCode(self, event):
        """Handle copy for focus editor"""
        if self._selected is None:
            return
        self._selected.Copy()

    def OnPasteCode(self, event):
        """Handle paste for focus editor"""
        if self._selected is None:
            return
        self._selected.Paste()

    def OnCutCode(self, event):
        """Handle paste for focus editor"""
        if self._selected is None:
            return
        self._selected.Cut()

    def OnSaveCode(self, event):
        """Handle save  event"""
        self.Commit()
        self.m_editor.ResetModified()
        self.m_init.ResetModified()
        self.UpdateModifiedTitle()

    def OnFullScreen(self, event):
        """ShowFullscreen"""
        from beatle.app.ui.pane import FullScreen
        curs = self._selected
        if self._fullScreen:
            self._fullScreen.LeaveFullScreen()
            self.UpdateModifiedTitle()
            self._fullScreen.Destroy()
            self._fullScreen = None
        else:
            self._fullScreen = FullScreen(self)
        wx.SafeYield()
        if curs:
            curs.SetFocus()

    def OnInitLeaveFocus(self, event):
        "Handle LeaveFocus event for init"
        self._selected = None
        event.Skip()
        super(ConstructorPane, self).OnKillFocus(event)


    def OnInitGetFocus(self, event):
        "Handle GetFocus event for init"
        self._selected = self.m_init
        event.Skip()
        super(ConstructorPane, self).OnGetFocus(event)

    def OnEditorLeaveFocus(self, event):
        "Handle LeaveFocus event for editor"
        self._selected = None
        event.Skip()
        super(ConstructorPane, self).OnKillFocus(event)

    def OnEditorGetFocus(self, event):
        "Handle GetFocus event for editor"
        self._selected = self.m_editor
        event.Skip()
        super(ConstructorPane, self).OnGetFocus(event)

