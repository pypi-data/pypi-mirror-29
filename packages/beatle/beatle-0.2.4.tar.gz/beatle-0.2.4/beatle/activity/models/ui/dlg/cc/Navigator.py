"""Subclass of Navigator, which is generated by wxFormBuilder."""

import wx

from beatle.activity.models.ui import ui as ui


# Implementing Navigator
class NavigatorDialog(ui.Navigator):
    """
    This dialog shows insertable elements
    """
    _escKeyId = wx.Window.NewControlId()
    _prefix_map = {}

    def __init__(self, parent, pos, _vars=None, _type=None):
        """Initialice the navigator dialog"""
        import beatle.app.resources as rc
        super(NavigatorDialog, self).__init__(parent)
        self.imglist = rc.GetBitmapImageList()
        self.m_tree.SetImageList(self.imglist)
        # The root element is a class :
        # iterate and add elements
        if _type is not None:
            self._mode = 'type'
            treeid = self.m_tree.AddRoot(wx.EmptyString)
            self.m_tree.SetPyData(treeid, wx.TreeItemData(_type))
            self.FillTree(treeid, _type)
        elif type(_vars) is dict:
            self._mode = 'vars'
            treeid = self.m_tree.AddRoot(wx.EmptyString)
            sorted_vars = _vars.keys()
            sorted_vars.sort()
            for var in sorted_vars:
                _detailed_type = _vars[var]
                _type = _detailed_type['type']
                childtreeid = self.m_tree.AppendItem(treeid, var,
                    image = _type.bitmap_index)
                self.m_tree.SetPyData(childtreeid, wx.TreeItemData(_type))
                if _detailed_type['ptr']:
                    _prefix='->'
                else:
                    _prefix='.'
                self.FillTree(childtreeid, _type, _prefix)
        root = self.m_tree.GetRootItem()
        if not root.IsOk() or self.m_tree.GetChildrenCount(root) == 0:
            self.empty = True
        else:
            self.empty = False
            first = self.m_tree.GetFirstChild(treeid)[0]
            if first.IsOk():
                self.m_tree.SelectItem(first)
            self._set_accelerators()
            self.Move(pos)
            self.Show(True)
            self._str = wx.EmptyString

    def FillTree(self, treeid, obj, prefix=wx.EmptyString):
        """Fill the tree"""
        from beatle.model import cc
        if obj is None:
            return
        if type(obj) is cc.Class:
            f = lambda x: x.inner_class == obj
            members = obj(cc.MemberData, filter=f, cut=True)
            members.sort(key=lambda x:'{prefix}{name}'.format(prefix=prefix,name=x.prefixed_name))
            for member in members:
                treeitemid = self.m_tree.AppendItem(treeid, '{prefix}{name}'.format(
                    prefix=prefix, name=member.prefixed_name), image=member.bitmap_index)
                if type(member.type_instance.base_type) is cc.Class:
                    # Add has child property
                    self.m_tree.SetItemHasChildren(treeitemid, True)
                self.m_tree.SetPyData(treeitemid, wx.TreeItemData(member))
            methods = obj(cc.MemberMethod,cc.IsClassMethod,cc.ExitMethod, cc.InitMethod, filter=f, cut=True)
            methods.sort(key=lambda x:'{prefix}{call}'.format(prefix=prefix,call=x.call))
            for method in methods:
                treeitemid = self.m_tree.AppendItem(treeid, '{prefix}{call}'.format(
                    prefix=prefix, call=method.call), image=method.bitmap_index)
                if type(method.type_instance.base_type) is cc.Class:
                    # Add has child property
                    self.m_tree.SetItemHasChildren(treeitemid, True)
                self.m_tree.SetPyData(treeitemid, wx.TreeItemData(method))
            #After that, we must add base clases
            for inh in obj(cc.Inheritance, filter=f, cut=True):
                treeitemid = self.m_tree.AppendItem(treeid, '{name}'.format(
                    name=inh._name), image=inh.bitmap_index)
                self._prefix_map[inh] = prefix
                self.m_tree.SetPyData(treeitemid, wx.TreeItemData(inh))
                self.m_tree.SetItemHasChildren(treeitemid, True)

    def OnSelectElement(self, event):
        """Handle to ensure scroll"""
        self.m_tree.ScrollTo(event.GetItem())

    def OnExpandItem(self, event):
        """Handle the expansion of the tree and inserting elemens"""
        from beatle.model import cc
        treeitem = event.GetItem()
        if not treeitem.IsOk():
            return
        obj = self.m_tree.GetPyData(treeitem).GetData()
        if obj is None:
            return
        if self.m_tree.GetChildrenCount(treeitem, False) > 0:
            return
        if type(obj) is cc.Inheritance:
            prefix = self._prefix_map[obj]
            target = obj._ancestor
        else:
            tti = obj.type_instance
            if type(tti.base_type) is not cc.Class:
                return
            if tti.is_ptr:
                prefix = '->'
            else:
                prefix = '.'
            target = tti.base_type
        self.FillTree(treeitem, target, prefix)

    def _set_accelerators(self):
        """Set the accelerator table"""
        aTable = wx.AcceleratorTable([
            wx.AcceleratorEntry(wx.ACCEL_NORMAL, wx.WXK_ESCAPE, NavigatorDialog._escKeyId)
        ])
        self.SetAcceleratorTable(aTable)
        self.Bind(wx.EVT_MENU, self.OnCancel, id=NavigatorDialog._escKeyId)

    def OnLoseFocus(self, event):
        """Cancel search"""
        self.EndModal(wx.ID_CANCEL)

    def OnCancel(self, event):
        """Cancel search"""
        self.EndModal(wx.ID_CANCEL)

    def ChainedString(self, treeitem):
        from beatle.model import cc
        if not treeitem.IsOk():
            return wx.EmptyString
        parentitem = self.m_tree.GetItemParent(treeitem)
        if not parentitem.IsOk():
            return wx.EmptyString
        obj = self.m_tree.GetPyData(treeitem).GetData()
        if type(obj) is cc.Inheritance:
            text =''
        else:
            text = self.m_tree.GetItemText(treeitem)            
        return self.ChainedString(parentitem)+text

    @property
    def value(self):
        """return selected text"""
        return self._str

    def OnChoice(self, event):
        """Do final selection"""
        self._str = self.ChainedString(self.m_tree.GetSelection())
        #remove annoying this->
        if self._str.startswith("this->"):
            self._str = self._str[6:]
        #remove annoying operator ->()
        if self._str.startswith("operator ->()"):
            self._str = self._str[13:]
        self.EndModal(wx.ID_OK)
