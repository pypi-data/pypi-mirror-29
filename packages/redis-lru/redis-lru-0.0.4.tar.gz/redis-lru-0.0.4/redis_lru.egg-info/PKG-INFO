Metadata-Version: 1.2
Name: redis-lru
Version: 0.0.4
Summary: LRU cache for Python. Use Redis as backend. Provides a dictionary-like object as well as a method decorator.
Home-page: https://github.com/leohowell/redis-lru
Author: Leo Howell
Author-email: leohowell.com@gmail.com
License: BSD
Description-Content-Type: UNKNOWN
Description: redis-lru
        =========
        
        Installation
        ------------
        
        .. code-block:: bash
        
            pip install redis-lru
        
        
        Introduction
        ------------
        
        It's often useful to have an lru redis cache. Of course, it's also desirable not to have the cache grow too large, and cache expiration is often desirable.
        This module provides such a cache.
        
        redis-lru supports CPython 2.7, 3.4+
        
        For the most part, you can just use it like this:
        
        .. code-block:: python
        
            from redis_lru import redis_lru_cache
        
            client = redis.StrictRedis()
        
            @redis_lru_cache(max_size=1024, expiration=15*60, node=client)
            def f(x):
                print("Calling f({})".format(x))
                return x
        
        
            f(3) # This will print "Calling f(3)", will return 3
            f(3) # This will not print anything, but will return 3 (unless 15 minutes have passed between the first and second function call).
        
        
        One can also create an `RedisLRUCacheDict` object, which have a redis backend behind with LRU eviction semantics:
        
        .. code-block:: python
        
            from redis_lru import RedisLRUCacheDict
        
            client = redis.StrictRedis()
        
            d = RedisLRUCacheDict(max_size=3, expiration=3, node=client)
        
            d['foo'] = 'bar'
            print(d['foo']) # prints "bar"
        
            import time
            time.sleep(4) # 4 seconds > 3 second cache expiry of d
            print(d['foo']) # KeyError
        
        In order to configure the decorator in a more detailed manner, or share a cache across functions, one can create a cache and pass it in as an argument to the cached function decorator:
        
        
        .. code-block:: python
        
            d = RedisLRUCacheDict(max_size=3, expiration=3, node=client)
        
            @redis_lru_cache(cache=d)
            def f(x):
                return x/2
        
        
        The doctests in the code provide more examples.
        
        
        0.0.4
        =====
        - Generate `unique_key` automatically so your may never get touch this argument.
        - Improved exception processing, now you won't receive any exception by default.
        - Added unittest for `redis_lru_cache` decorator and `RedisLRUCacheDict`
        - Added more type of cache usage statistic type like `POP`, `DEL` etc.
        - Added changes log.
        
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Environment :: Web Environment
Classifier: License :: OSI Approved :: BSD License
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: Implementation :: CPython
Requires-Python: >= 2.7, !=3.0.*, !=3.1.*, !=3.2.*, != 3.3.*
