#! /usr/bin/env python
#
# Copyright (C) 2017 Marco Barisione
#
# Released under the terms of the GNU LGPL license version 2.1 or later.

from __future__ import print_function

import argparse
import os
import shutil
import subprocess
import sys
import time

try:
    # Python 3.
    from shlex import quote
except ImportError:
    from pipes import quote

import tempdir


BASE_DOCKERFILE = '''\
# Generated by Inception.

FROM %(distro_and_tag)s

%(basic_setup)s

ADD /sudoers.txt /etc/sudoers

# The docker group doesn't exist in RPM-based systems when using distro packages. See
# http://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/
RUN \
    useradd -m -s /bin/bash test-user && \
    if cat /etc/group | grep docker > /dev/null; then \
        usermod -a -G docker test-user; \
    fi

ENV USER test-user
USER test-user
'''

# For Ubuntu we use the distro packages.
DEB_BASIC_SETUP = '''\
RUN \
    export DEBIAN_FRONTEND=noninteractive && \
    apt-get update -qqy && \
    apt-get install -qqy -o=Dpkg::Use-Pty=0 \
        --no-install-recommends \
        ca-certificates \
        docker.io \
        make \
        python \
        sudo \
        && \
    apt-get clean -qq
'''

# For CentOS we use the official upstream packages.
CENTOS_BASIC_SETUP = '''\
RUN \
    yum install -y \
        make \
        python \
        sudo \
        yum-utils \
        which \
        && \
    yum-config-manager \
        --add-repo \
        https://download.docker.com/linux/centos/docker-ce.repo \
        && \
    yum -y install docker-ce
'''

# For Fedora we use the distro packages.
FEDORA_BASIC_SETUP = '''\
RUN \
    yum install -y \
        docker-engine \
        make \
        python \
        sudo \
        yum-utils \
        which

# This is needed because we start dockerd without using systemd.
RUN \
    for current in /usr/bin/dockerd-current /usr/libexec/docker/docker-*-current; do \
        link=$(echo "$current" | sed -e 's,-current$,,'); \
        ln -s "$current" "$link"; \
    done
'''

SUDOERS = '''\
root ALL=(ALL) ALL
test-user ALL=(ALL) NOPASSWD: ALL
Defaults    env_reset
Defaults    secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/libexec/docker"
'''

CONTAINER_RUNNER_SCRIPT = '''\
#! /bin/bash

host_date="$1"
if [ "$host_date" != "NOSYNC" ]; then
    sudo date -s "@$host_date" > /dev/null
fi

if which dockerd > /dev/null 2>&1; then
    dockerd_command="dockerd"
else
    dockerd_command="docker daemon"
fi

echo "RUNNING DOCKERD: $dockerd_command"
sudo $dockerd_command > dockerd.log 2>&1 &

cd /inception
%(commands)s
'''


def error(msg):
    if not msg.endswith('\n'):
        msg += '\n'
    sys.stderr.write(msg)


def die(msg):
    error(msg)
    raise SystemExit(1)


def quiet_exec(commands, *args, **kwargs):
    try:
        return subprocess.check_output(commands, *args, stderr=subprocess.STDOUT, **kwargs)
    except subprocess.CalledProcessError as exc:
        die('Failed to execute commands: %s.\n'
            'The program output was:\n'
            '========\n'
            '%s'
            '========' %
            (commands, exc.output))


def build_container(image_name, dockerfile_content):
    with tempdir.TempDir() as dockerfile_dir:
        with open(os.path.join(dockerfile_dir, 'Dockerfile'), 'w') as dockerfile_file:
            dockerfile_file.write(dockerfile_content)

        with open(os.path.join(dockerfile_dir, 'sudoers.txt'), 'w') as sudoers_content:
            sudoers_content.write(SUDOERS)

        quiet_exec(['docker', 'build', '--tag', image_name, dockerfile_dir])


def run(image_name, commands, added_files, added_scripts, save_back_files):
    # This is the volume where we store /var/lib/docker on the host. Doing this means that
    # future invokations of docker in the outer container won't have to redownload the
    # images.
    # We use a volume and not a directory as that doesn't work on macOS.
    quiet_exec(['docker', 'volume', 'create', image_name])

    def fixup_container_basenames(paths):
        result = []
        for host_path, container_basename in paths:
            if container_basename == '_':
                container_basename = os.path.basename(host_path)

            if '/' in container_basename:
                die('Invalid container basename "%s". This should only be the file name without '
                    'any directory path. The added files and scripts will be then available all '
                    'in the container directory "/inception".' % container_basename)

            result.append((host_path, container_basename))

        return result

    added_files = fixup_container_basenames(added_files)
    added_scripts = fixup_container_basenames(added_scripts)
    save_back_files = fixup_container_basenames(save_back_files)

    with tempdir.TempDir() as tmp_dir:
        tmp_dir = os.path.realpath(tmp_dir)

        inception_dir = os.path.join(tmp_dir, 'inception')
        os.makedirs(inception_dir)

        inception_priv_dir = os.path.join(tmp_dir, 'inception-private')
        os.makedirs(inception_priv_dir)

        def iter_host_paths(paths):
            for host_path, container_basename in paths:
                container_path_on_host = os.path.join(inception_dir, container_basename)
                yield host_path, container_path_on_host

        # Copy files and scripts.
        for host_path, container_path_on_host in iter_host_paths(added_files + added_scripts):
            try:
                shutil.copyfile(host_path, container_path_on_host)
            except OSError as exc:
                die('Cannot share "%s": %s.' % (host_path, exc))

        # Set the right permissions for scripts.
        for _, container_path_on_host in iter_host_paths(added_scripts):
            os.chmod(container_path_on_host, 0755)

        # Prepare the script which will run the commands.
        command_string = ' '.join([quote(arg) for arg in commands])
        content = CONTAINER_RUNNER_SCRIPT % dict(
            commands=command_string,
            )
        with open(os.path.join(inception_priv_dir, 'runner'), 'w') as runner_file:
            os.fchmod(runner_file.fileno(), 0755)
            runner_file.write(content)

        # Run the script/commands.
        if sys.platform == 'darwin':
            host_time = str(int(time.time()))
        else:
            host_time = 'NOSYNC'

        try:
            subprocess.check_call([
                'docker',
                'run',
                '--privileged',
                '-v', '%s:/var/lib/docker' % image_name,
                '-v', '%s:/inception/' % inception_dir,
                '-v', '%s:/inception-private/' % inception_priv_dir,
                '--workdir', '/inception-private/',
                '-it',
                image_name,
                '/inception-private/runner',
                host_time,
                ])
        except subprocess.CalledProcessError as exc:
            die('Failed to run script in "%s": %s.' % (image_name, exc))

        # Save back the output files.
        for host_path, container_path_on_host in iter_host_paths(save_back_files):
            try:
                shutil.move(container_path_on_host, host_path)
            except (OSError, IOError) as exc:
                error('Cannot save to host file "%s": %s.' % (host_path, exc))


def main(arguments):
    # Parse the arguments.
    parser = argparse.ArgumentParser(
        description='Runs code which may use Docker inside a Docker container.')

    parser.add_argument(
        '--add',
        action='append',
        nargs=2,
        dest='added_files',
        metavar=('HOST-PATH', 'CONTAINER-BASE-NAME'),
        help='add the file at HOST-PATH to the container at /inception/CONTAINER-BASE-NAME')

    parser.add_argument(
        '--add-script',
        action='append',
        nargs=2,
        dest='added_scripts',
        metavar=('HOST-PATH', 'CONTAINER-BASE-NAME'),
        help='add the script at HOST-PATH to the container at /inception/CONTAINER-BASE-NAME and '
        'make sure it\'s executable')

    parser.add_argument(
        '--save-back',
        action='append',
        nargs=2,
        dest='save_back_files',
        metavar=('HOST-PATH', 'CONTAINER-BASE-NAME'),
        help='when done, copy back the file in the container at /inception/CONTAINER-BASE-NAME to '
        'the host at HOST-PATH')

    parser.add_argument(
        'distro_and_tag',
        metavar='DISTRO',
        help='the distro to use in Docker format '
        '(for instance "ubuntu:latest", "debian:testing", "centos", "fedora:latest", etc.)')

    parser.add_argument(
        'remainder',
        metavar='COMMANDS',
        nargs=argparse.REMAINDER,
        help='the command line to execute in the container; the working directory is set to '
        '/inception, where the added files were copied')

    parsed_args = parser.parse_args(arguments[1:])

    split_distro = parsed_args.distro_and_tag.split(':', 1)
    if len(split_distro) == 1:
        distro_name = split_distro[0]
        distro_tag = 'latest'
    elif len(split_distro) == 2:
        distro_name, distro_tag = split_distro
    else:
        die('Invalid distribution: "%s".' % parsed_args.distro_and_tag)

    if distro_name not in ('ubuntu', 'debian', 'centos', 'fedora'):
        die('Invalid distro name: "%s".' % distro_name)

    if not distro_tag:
        die('Invalid empty distro tag. If you don\'t want to specify one, you can omit the '
            '":" entirely.')

    # And now actually run stuff.
    image_name = 'inception-' + parsed_args.distro_and_tag.replace(':', '-')

    if distro_name in ('debian', 'ubuntu'):
        basic_setup = DEB_BASIC_SETUP
    elif distro_name == 'centos':
        basic_setup = CENTOS_BASIC_SETUP
    elif distro_name == 'fedora':
        basic_setup = FEDORA_BASIC_SETUP
    else:
        assert False, 'Unexpected distro "%s" even if we already checked earlier' % distro_name

    dockerfile_content = BASE_DOCKERFILE % \
        dict(
            basic_setup=basic_setup,
            distro_and_tag=parsed_args.distro_and_tag,
            )
    build_container(image_name, dockerfile_content)

    run(image_name,
        parsed_args.remainder,
        parsed_args.added_files or [],
        parsed_args.added_scripts or [],
        parsed_args.save_back_files or [])


if __name__ == '__main__':
    main(sys.argv)
