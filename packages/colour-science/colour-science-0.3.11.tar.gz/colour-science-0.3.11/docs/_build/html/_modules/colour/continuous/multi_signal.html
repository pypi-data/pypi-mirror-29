

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>colour.continuous.multi_signal &mdash; Colour 0.3.11 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="Colour 0.3.11 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Colour
          

          
            
            <img src="../../../_static/Logo_Small_001.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../manual.html">Colour Manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Colour</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>colour.continuous.multi_signal</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for colour.continuous.multi_signal</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Multi Signal</span>
<span class="sd">============</span>

<span class="sd">Defines the class implementing support for multi-continuous signal:</span>

<span class="sd">-   :class:`colour.continuous.MultiSignal`</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="c1"># Python 3 compatibility.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">div</span><span class="p">,</span> <span class="n">idiv</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">truediv</span><span class="p">,</span> <span class="n">itruediv</span>

    <span class="n">div</span> <span class="o">=</span> <span class="n">truediv</span>
    <span class="n">idiv</span> <span class="o">=</span> <span class="n">itruediv</span>

<span class="kn">from</span> <span class="nn">colour.constants</span> <span class="k">import</span> <span class="n">DEFAULT_FLOAT_DTYPE</span>
<span class="kn">from</span> <span class="nn">colour.continuous</span> <span class="k">import</span> <span class="n">AbstractContinuousFunction</span><span class="p">,</span> <span class="n">Signal</span>
<span class="kn">from</span> <span class="nn">colour.utilities</span> <span class="k">import</span> <span class="n">first_item</span><span class="p">,</span> <span class="n">is_pandas_installed</span><span class="p">,</span> <span class="n">tsplit</span><span class="p">,</span> <span class="n">tstack</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Colour Developers&#39;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s1">&#39;Copyright (C) 2013-2018 - Colour Developers&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;New BSD License - http://opensource.org/licenses/BSD-3-Clause&#39;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s1">&#39;Colour Developers&#39;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s1">&#39;colour-science@googlegroups.com&#39;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;Production&#39;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MultiSignal&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="MultiSignal"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal">[docs]</a><span class="k">class</span> <span class="nc">MultiSignal</span><span class="p">(</span><span class="n">AbstractContinuousFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines the base class for multi-continuous signal, a container for</span>
<span class="sd">    multiple :class:`colour.continuous.Signal` sub-class instances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : Series or Dataframe or Signal or MultiSignal or array_like or \</span>
<span class="sd">dict_like, optional</span>
<span class="sd">        Data to be stored in the multi-continuous signal.</span>
<span class="sd">    domain : array_like, optional</span>
<span class="sd">        Values to initialise the multiple :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances :attr:`colour.continuous.Signal.domain` attribute</span>
<span class="sd">        with. If both ``data`` and ``domain`` arguments are defined, the latter</span>
<span class="sd">        will be used to initialise the :attr:`colour.continuous.Signal.domain`</span>
<span class="sd">        attribute.</span>
<span class="sd">    labels : array_like, optional</span>
<span class="sd">        Names to use for the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">        instances.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    name : unicode, optional</span>
<span class="sd">        Multi-continuous signal name.</span>
<span class="sd">    dtype : type, optional</span>
<span class="sd">        **{np.float16, np.float32, np.float64, np.float128}**,</span>
<span class="sd">        Floating point data type.</span>
<span class="sd">    interpolator : object, optional</span>
<span class="sd">        Interpolator class type to use as interpolating function for the</span>
<span class="sd">        :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">    interpolator_args : dict_like, optional</span>
<span class="sd">        Arguments to use when instantiating the interpolating function</span>
<span class="sd">        of the :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">    extrapolator : object, optional</span>
<span class="sd">        Extrapolator class type to use as extrapolating function for the</span>
<span class="sd">        :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">    extrapolator_args : dict_like, optional</span>
<span class="sd">        Arguments to use when instantiating the extrapolating function</span>
<span class="sd">        of the :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">    signal_type : type, optional</span>
<span class="sd">        The :class:`colour.continuous.Signal` sub-class type used for</span>
<span class="sd">        instances.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype</span>
<span class="sd">    domain</span>
<span class="sd">    range</span>
<span class="sd">    interpolator</span>
<span class="sd">    interpolator_args</span>
<span class="sd">    extrapolator</span>
<span class="sd">    extrapolator_args</span>
<span class="sd">    function</span>
<span class="sd">    signals</span>
<span class="sd">    labels</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __str__</span>
<span class="sd">    __repr__</span>
<span class="sd">    __getitem__</span>
<span class="sd">    __setitem__</span>
<span class="sd">    __contains__</span>
<span class="sd">    __eq__</span>
<span class="sd">    __ne__</span>
<span class="sd">    arithmetical_operation</span>
<span class="sd">    multi_signal_unpack_data</span>
<span class="sd">    fill_nan</span>
<span class="sd">    to_dataframe</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Instantiation with implicit *domain* and a single signal:</span>

<span class="sd">    &gt;&gt;&gt; range_ = np.linspace(10, 100, 10)</span>
<span class="sd">    &gt;&gt;&gt; print(MultiSignal(range_))</span>
<span class="sd">    [[   0.   10.]</span>
<span class="sd">     [   1.   20.]</span>
<span class="sd">     [   2.   30.]</span>
<span class="sd">     [   3.   40.]</span>
<span class="sd">     [   4.   50.]</span>
<span class="sd">     [   5.   60.]</span>
<span class="sd">     [   6.   70.]</span>
<span class="sd">     [   7.   80.]</span>
<span class="sd">     [   8.   90.]</span>
<span class="sd">     [   9.  100.]]</span>

<span class="sd">    Instantiation with explicit *domain* and a single signal:</span>

<span class="sd">    &gt;&gt;&gt; domain = np.arange(100, 1100, 100)</span>
<span class="sd">    &gt;&gt;&gt; print(MultiSignal(range_, domain))</span>
<span class="sd">    [[  100.    10.]</span>
<span class="sd">     [  200.    20.]</span>
<span class="sd">     [  300.    30.]</span>
<span class="sd">     [  400.    40.]</span>
<span class="sd">     [  500.    50.]</span>
<span class="sd">     [  600.    60.]</span>
<span class="sd">     [  700.    70.]</span>
<span class="sd">     [  800.    80.]</span>
<span class="sd">     [  900.    90.]</span>
<span class="sd">     [ 1000.   100.]]</span>

<span class="sd">    Instantiation with multiple signals:</span>

<span class="sd">    &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">    &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">    &gt;&gt;&gt; print(MultiSignal(range_, domain))</span>
<span class="sd">    [[  100.    10.    20.    30.]</span>
<span class="sd">     [  200.    20.    30.    40.]</span>
<span class="sd">     [  300.    30.    40.    50.]</span>
<span class="sd">     [  400.    40.    50.    60.]</span>
<span class="sd">     [  500.    50.    60.    70.]</span>
<span class="sd">     [  600.    60.    70.    80.]</span>
<span class="sd">     [  700.    70.    80.    90.]</span>
<span class="sd">     [  800.    80.    90.   100.]</span>
<span class="sd">     [  900.    90.   100.   110.]</span>
<span class="sd">     [ 1000.   100.   110.   120.]]</span>

<span class="sd">    Instantiation with a *dict*:</span>

<span class="sd">    &gt;&gt;&gt; print(MultiSignal(dict(zip(domain, range_))))</span>
<span class="sd">    [[  100.    10.    20.    30.]</span>
<span class="sd">     [  200.    20.    30.    40.]</span>
<span class="sd">     [  300.    30.    40.    50.]</span>
<span class="sd">     [  400.    40.    50.    60.]</span>
<span class="sd">     [  500.    50.    60.    70.]</span>
<span class="sd">     [  600.    60.    70.    80.]</span>
<span class="sd">     [  700.    70.    80.    90.]</span>
<span class="sd">     [  800.    80.    90.   100.]</span>
<span class="sd">     [  900.    90.   100.   110.]</span>
<span class="sd">     [ 1000.   100.   110.   120.]]</span>

<span class="sd">    Instantiation using a *Signal* sub-class:</span>

<span class="sd">    &gt;&gt;&gt; class NotSignal(Signal):</span>
<span class="sd">    ...     pass</span>

<span class="sd">    &gt;&gt;&gt; multi_signal = MultiSignal(range_, domain, signal_type=NotSignal)</span>
<span class="sd">    &gt;&gt;&gt; print(multi_signal)</span>
<span class="sd">    [[  100.    10.    20.    30.]</span>
<span class="sd">     [  200.    20.    30.    40.]</span>
<span class="sd">     [  300.    30.    40.    50.]</span>
<span class="sd">     [  400.    40.    50.    60.]</span>
<span class="sd">     [  500.    50.    60.    70.]</span>
<span class="sd">     [  600.    60.    70.    80.]</span>
<span class="sd">     [  700.    70.    80.    90.]</span>
<span class="sd">     [  800.    80.    90.   100.]</span>
<span class="sd">     [  900.    90.   100.   110.]</span>
<span class="sd">     [ 1000.   100.   110.   120.]]</span>
<span class="sd">     &gt;&gt;&gt; type(multi_signal.signals[0])  # doctest: +SKIP</span>
<span class="sd">     &lt;class &#39;multi_signal.NotSignal&#39;&gt;</span>

<span class="sd">    Instantiation with a *Pandas* *Series*:</span>

<span class="sd">    &gt;&gt;&gt; if is_pandas_installed():</span>
<span class="sd">    ...     from pandas import Series</span>
<span class="sd">    ...     print(MultiSignal(  # doctest: +SKIP</span>
<span class="sd">    ...         Series(dict(zip(domain, np.linspace(10, 100, 10))))))</span>
<span class="sd">    [[  100.    10.]</span>
<span class="sd">     [  200.    20.]</span>
<span class="sd">     [  300.    30.]</span>
<span class="sd">     [  400.    40.]</span>
<span class="sd">     [  500.    50.]</span>
<span class="sd">     [  600.    60.]</span>
<span class="sd">     [  700.    70.]</span>
<span class="sd">     [  800.    80.]</span>
<span class="sd">     [  900.    90.]</span>
<span class="sd">     [ 1000.   100.]]</span>

<span class="sd">    Instantiation with a *Pandas* *Dataframe*:</span>

<span class="sd">    &gt;&gt;&gt; if is_pandas_installed():</span>
<span class="sd">    ...     from pandas import DataFrame</span>
<span class="sd">    ...     data = dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], tsplit(range_)))</span>
<span class="sd">    ...     print(MultiSignal(  # doctest: +SKIP</span>
<span class="sd">    ...         DataFrame(data, domain)))</span>
<span class="sd">    [[  100.    10.    20.    30.]</span>
<span class="sd">     [  200.    20.    30.    40.]</span>
<span class="sd">     [  300.    30.    40.    50.]</span>
<span class="sd">     [  400.    40.    50.    60.]</span>
<span class="sd">     [  500.    50.    60.    70.]</span>
<span class="sd">     [  600.    60.    70.    80.]</span>
<span class="sd">     [  700.    70.    80.    90.]</span>
<span class="sd">     [  800.    80.    90.   100.]</span>
<span class="sd">     [  900.    90.   100.   110.]</span>
<span class="sd">     [ 1000.   100.   110.   120.]]</span>

<span class="sd">    Retrieving domain *y* variable for arbitrary range *x* variable:</span>

<span class="sd">    &gt;&gt;&gt; x = 150</span>
<span class="sd">    &gt;&gt;&gt; range_ = tstack([np.sin(np.linspace(0, 1, 10))] * 3)</span>
<span class="sd">    &gt;&gt;&gt; range_ += np.array([0.0, 0.25, 0.5])</span>
<span class="sd">    &gt;&gt;&gt; MultiSignal(range_, domain)[x]  # doctest: +ELLIPSIS</span>
<span class="sd">    array([ 0.0359701...,  0.2845447...,  0.5331193...])</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(100, 1000, 3)</span>
<span class="sd">    &gt;&gt;&gt; MultiSignal(range_, domain)[x]  # doctest: +ELLIPSIS</span>
<span class="sd">    array([[  4.4085384...e-20,   2.5000000...e-01,   5.0000000...e-01],</span>
<span class="sd">           [  4.7669395...e-01,   7.2526859...e-01,   9.7384323...e-01],</span>
<span class="sd">           [  8.4147098...e-01,   1.0914709...e+00,   1.3414709...e+00]])</span>

<span class="sd">    Using an alternative interpolating function:</span>

<span class="sd">    &gt;&gt;&gt; x = 150</span>
<span class="sd">    &gt;&gt;&gt; from colour.algebra import CubicSplineInterpolator</span>
<span class="sd">    &gt;&gt;&gt; MultiSignal(</span>
<span class="sd">    ...     range_,</span>
<span class="sd">    ...     domain,</span>
<span class="sd">    ...     interpolator=CubicSplineInterpolator)[x]  # doctest: +ELLIPSIS</span>
<span class="sd">    array([ 0.0555274...,  0.3055274...,  0.5555274...])</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(100, 1000, 3)</span>
<span class="sd">    &gt;&gt;&gt; MultiSignal(</span>
<span class="sd">    ...     range_,</span>
<span class="sd">    ...     domain,</span>
<span class="sd">    ...     interpolator=CubicSplineInterpolator)[x]  # doctest: +ELLIPSIS</span>
<span class="sd">    array([[ 0.       ...,  0.25     ...,  0.5      ...],</span>
<span class="sd">           [ 0.4794253...,  0.7294253...,  0.9794253...],</span>
<span class="sd">           [ 0.8414709...,  1.0914709...,  1.3414709...]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MultiSignal.__init__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiSignal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_signal_unpack_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span>
                                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the continuous signal dtype.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : type</span>
<span class="sd">            Value to set the continuous signal dtype with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            Continuous signal dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@dtype</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for **self.dtype** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances independent domain :math:`x` variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : array_like</span>
<span class="sd">            Value to set the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances independent domain :math:`x` variable with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances independent</span>
<span class="sd">            domain :math:`x` variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">domain</span>

    <span class="nd">@domain</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.domain** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances corresponding range :math:`y` variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : array_like</span>
<span class="sd">            Value to set the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances corresponding range :math:`y` variable with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances corresponding</span>
<span class="sd">            range :math:`y` variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tstack</span><span class="p">([</span><span class="n">signal</span><span class="o">.</span><span class="n">range</span> <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="nd">@range</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.range** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">signal</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">),</span> <span class="p">(</span>
                    <span class="s1">&#39;Corresponding &quot;y&quot; variable columns must have &#39;</span>
                    <span class="s1">&#39;same count than underlying &quot;Signal&quot; components!&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">signal</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">tsplit</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                    <span class="n">signal</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances interpolator type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : type</span>
<span class="sd">            Value to set the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances interpolator type with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances interpolator</span>
<span class="sd">            type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">interpolator</span>

    <span class="nd">@interpolator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.interpolator** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interpolator_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances interpolator instantiation time arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : dict</span>
<span class="sd">            Value to set the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances interpolator instantiation time arguments to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances interpolator</span>
<span class="sd">            instantiation time arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">interpolator_args</span>

    <span class="nd">@interpolator_args</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">interpolator_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.interpolator_args** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">interpolator_args</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extrapolator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances extrapolator type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : type</span>
<span class="sd">            Value to set the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances extrapolator type with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances extrapolator</span>
<span class="sd">            type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">extrapolator</span>

    <span class="nd">@extrapolator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">extrapolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.extrapolator** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">extrapolator</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extrapolator_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances extrapolator instantiation time arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : dict</span>
<span class="sd">            Value to set the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances extrapolator instantiation time arguments to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances extrapolator</span>
<span class="sd">            instantiation time arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">extrapolator_args</span>

    <span class="nd">@extrapolator_args</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">extrapolator_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.extrapolator_args** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">extrapolator_args</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances callable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : object</span>
<span class="sd">            Attribute value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        callable</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances callable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        -   This property is read only.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">function</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">signals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : Series or Dataframe or Signal or MultiSignal or array_like or \</span>
<span class="sd">dict_like</span>
<span class="sd">            Attribute value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        OrderedDict</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span>

    <span class="nd">@signals</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.signals** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_signal_unpack_data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Getter and setter property for the :class:`colour.continuous.Signal`</span>
<span class="sd">        sub-class instances name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : array_like</span>
<span class="sd">            Value to set the :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instance name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@labels</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the **self.labels** property.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;&quot;labels&quot; length does not match &quot;signals&quot; length!&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">signal</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>

<div class="viewcode-block" id="MultiSignal.__str__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a formatted string representation of the multi-continuous</span>
<span class="sd">        signal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unicode</span>
<span class="sd">            Formatted string representation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; domain = np.arange(0, 10, 1)</span>
<span class="sd">        &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">        &gt;&gt;&gt; print(MultiSignal(range_))</span>
<span class="sd">        [[   0.   10.   20.   30.]</span>
<span class="sd">         [   1.   20.   30.   40.]</span>
<span class="sd">         [   2.   30.   40.   50.]</span>
<span class="sd">         [   3.   40.   50.   60.]</span>
<span class="sd">         [   4.   50.   60.   70.]</span>
<span class="sd">         [   5.   60.   70.   80.]</span>
<span class="sd">         [   6.   70.   80.   90.]</span>
<span class="sd">         [   7.   80.   90.  100.]</span>
<span class="sd">         [   8.   90.  100.  110.]</span>
<span class="sd">         [   9.  100.  110.  120.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MultiSignal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>

<div class="viewcode-block" id="MultiSignal.__repr__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an evaluable string representation of the multi-continuous</span>
<span class="sd">        signal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unicode</span>
<span class="sd">            Evaluable string representation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; domain = np.arange(0, 10, 1)</span>
<span class="sd">        &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">        &gt;&gt;&gt; MultiSignal(range_)  # doctest: +ELLIPSIS</span>
<span class="sd">        MultiSignal([[   0.,   10.,   20.,   30.],</span>
<span class="sd">                     [   1.,   20.,   30.,   40.],</span>
<span class="sd">                     [   2.,   30.,   40.,   50.],</span>
<span class="sd">                     [   3.,   40.,   50.,   60.],</span>
<span class="sd">                     [   4.,   50.,   60.,   70.],</span>
<span class="sd">                     [   5.,   60.,   70.,   80.],</span>
<span class="sd">                     [   6.,   70.,   80.,   90.],</span>
<span class="sd">                     [   7.,   80.,   90.,  100.],</span>
<span class="sd">                     [   8.,   90.,  100.,  110.],</span>
<span class="sd">                     [   9.,  100.,  110.,  120.]],</span>
<span class="sd">                    labels=[0, 1, 2],</span>
<span class="sd">                    interpolator=KernelInterpolator,</span>
<span class="sd">                    interpolator_args={},</span>
<span class="sd">                    extrapolator=Extrapolator,</span>
<span class="sd">                    extrapolator_args={...)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">representation</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">)))</span>
            <span class="n">representation</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;array&#39;</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="n">representation</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;       [&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">[&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">representation</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">labels=</span><span class="si">{2}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">interpolator=</span><span class="si">{3}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">interpolator_args=</span><span class="si">{4}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">extrapolator=</span><span class="si">{5}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">extrapolator_args=</span><span class="si">{6}</span><span class="s1">)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                  <span class="n">representation</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                  <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="vm">__name__</span>
                                  <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="p">,</span>
                                  <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolator_args</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">extrapolator</span><span class="o">.</span><span class="vm">__name__</span>
                                  <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">extrapolator</span><span class="p">,</span>
                                  <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extrapolator_args</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">representation</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># TODO: Discuss what is the most suitable behaviour, either the</span>
            <span class="c1"># following or __str__ one.</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">()&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSignal.__getitem__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the corresponding range :math:`y` variable for independent</span>
<span class="sd">        domain :math:`x` variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : numeric, array_like or slice</span>
<span class="sd">            Independent domain :math:`x` variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numeric or ndarray</span>
<span class="sd">            math:`y` range value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal)</span>
<span class="sd">        [[   0.   10.   20.   30.]</span>
<span class="sd">         [   1.   20.   30.   40.]</span>
<span class="sd">         [   2.   30.   40.   50.]</span>
<span class="sd">         [   3.   40.   50.   60.]</span>
<span class="sd">         [   4.   50.   60.   70.]</span>
<span class="sd">         [   5.   60.   70.   80.]</span>
<span class="sd">         [   6.   70.   80.   90.]</span>
<span class="sd">         [   7.   80.   90.  100.]</span>
<span class="sd">         [   8.   90.  100.  110.]</span>
<span class="sd">         [   9.  100.  110.  120.]]</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[0]</span>
<span class="sd">        array([ 10.,  20.,  30.])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[np.array([0, 1, 2])]</span>
<span class="sd">        array([[ 10.,  20.,  30.],</span>
<span class="sd">               [ 20.,  30.,  40.],</span>
<span class="sd">               [ 30.,  40.,  50.]])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[0:3]</span>
<span class="sd">        array([[ 10.,  20.,  30.],</span>
<span class="sd">               [ 20.,  30.,  40.],</span>
<span class="sd">               [ 30.,  40.,  50.]])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[np.linspace(0, 5, 5)]  # doctest: +ELLIPSIS</span>
<span class="sd">        array([[ 10.       ...,  20.       ...,  30.       ...],</span>
<span class="sd">               [ 22.8348902...,  32.8046056...,  42.774321 ...],</span>
<span class="sd">               [ 34.8004492...,  44.7434347...,  54.6864201...],</span>
<span class="sd">               [ 47.5535392...,  57.5232546...,  67.4929700...],</span>
<span class="sd">               [ 60.       ...,  70.       ...,  80.       ...]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tstack</span><span class="p">([</span><span class="n">signal</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No underlying &quot;Signal&quot; defined!&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSignal.__setitem__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the corresponding range :math:`y` variable for independent domain</span>
<span class="sd">        :math:`x` variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : numeric, array_like or slice</span>
<span class="sd">            Independent domain :math:`x` variable.</span>
<span class="sd">        y : numeric or ndarray</span>
<span class="sd">            Corresponding range :math:`y` variable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; domain = np.arange(0, 10, 1)</span>
<span class="sd">        &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal)</span>
<span class="sd">        [[   0.   10.   20.   30.]</span>
<span class="sd">         [   1.   20.   30.   40.]</span>
<span class="sd">         [   2.   30.   40.   50.]</span>
<span class="sd">         [   3.   40.   50.   60.]</span>
<span class="sd">         [   4.   50.   60.   70.]</span>
<span class="sd">         [   5.   60.   70.   80.]</span>
<span class="sd">         [   6.   70.   80.   90.]</span>
<span class="sd">         [   7.   80.   90.  100.]</span>
<span class="sd">         [   8.   90.  100.  110.]</span>
<span class="sd">         [   9.  100.  110.  120.]]</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[0] = 20</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[0]</span>
<span class="sd">        array([ 20.,  20.,  20.])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[np.array([0, 1, 2])] = 30</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[np.array([0, 1, 2])]</span>
<span class="sd">        array([[ 30.,  30.,  30.],</span>
<span class="sd">               [ 30.,  30.,  30.],</span>
<span class="sd">               [ 30.,  30.,  30.]])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[0:3] = 40</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[0:3]</span>
<span class="sd">        array([[ 40.,  40.,  40.],</span>
<span class="sd">               [ 40.,  40.,  40.],</span>
<span class="sd">               [ 40.,  40.,  40.]])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[np.linspace(0, 5, 5)] = 50</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal)</span>
<span class="sd">        [[   0.     50.     50.     50.  ]</span>
<span class="sd">         [   1.     40.     40.     40.  ]</span>
<span class="sd">         [   1.25   50.     50.     50.  ]</span>
<span class="sd">         [   2.     40.     40.     40.  ]</span>
<span class="sd">         [   2.5    50.     50.     50.  ]</span>
<span class="sd">         [   3.     40.     50.     60.  ]</span>
<span class="sd">         [   3.75   50.     50.     50.  ]</span>
<span class="sd">         [   4.     50.     60.     70.  ]</span>
<span class="sd">         [   5.     50.     50.     50.  ]</span>
<span class="sd">         [   6.     70.     80.     90.  ]</span>
<span class="sd">         [   7.     80.     90.    100.  ]</span>
<span class="sd">         [   8.     90.    100.    110.  ]</span>
<span class="sd">         [   9.    100.    110.    120.  ]]</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[np.array([0, 1, 2])] = np.array([10, 20, 30])</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal)</span>
<span class="sd">        [[   0.     10.     20.     30.  ]</span>
<span class="sd">         [   1.     10.     20.     30.  ]</span>
<span class="sd">         [   1.25   50.     50.     50.  ]</span>
<span class="sd">         [   2.     10.     20.     30.  ]</span>
<span class="sd">         [   2.5    50.     50.     50.  ]</span>
<span class="sd">         [   3.     40.     50.     60.  ]</span>
<span class="sd">         [   3.75   50.     50.     50.  ]</span>
<span class="sd">         [   4.     50.     60.     70.  ]</span>
<span class="sd">         [   5.     50.     50.     50.  ]</span>
<span class="sd">         [   6.     70.     80.     90.  ]</span>
<span class="sd">         [   7.     80.     90.    100.  ]</span>
<span class="sd">         [   8.     90.    100.    110.  ]</span>
<span class="sd">         [   9.    100.    110.    120.  ]]</span>
<span class="sd">        &gt;&gt;&gt; y = np.arange(1, 10, 1).reshape(3, 3)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[np.array([0, 1, 2])] = y</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal)</span>
<span class="sd">        [[   0.      1.      2.      3.  ]</span>
<span class="sd">         [   1.      4.      5.      6.  ]</span>
<span class="sd">         [   1.25   50.     50.     50.  ]</span>
<span class="sd">         [   2.      7.      8.      9.  ]</span>
<span class="sd">         [   2.5    50.     50.     50.  ]</span>
<span class="sd">         [   3.     40.     50.     60.  ]</span>
<span class="sd">         [   3.75   50.     50.     50.  ]</span>
<span class="sd">         [   4.     50.     60.     70.  ]</span>
<span class="sd">         [   5.     50.     50.     50.  ]</span>
<span class="sd">         [   6.     70.     80.     90.  ]</span>
<span class="sd">         [   7.     80.     90.    100.  ]</span>
<span class="sd">         [   8.     90.    100.    110.  ]</span>
<span class="sd">         [   9.    100.    110.    120.  ]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;Corresponding &quot;y&quot; variable must be a numeric or a 1-dimensional &#39;</span>
            <span class="s1">&#39;or 2-dimensional array!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;Corresponding &quot;y&quot; variable columns must have same count than &#39;</span>
            <span class="s1">&#39;underlying &quot;Signal&quot; components!&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">signal</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">tsplit</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
            <span class="n">signal</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span></div>

<div class="viewcode-block" id="MultiSignal.__contains__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the multi-continuous signal contains given independent</span>
<span class="sd">        domain :math:`x` variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : numeric, array_like or slice</span>
<span class="sd">            Independent domain :math:`x` variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Is :math:`x` domain value contained.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; range_ = np.linspace(10, 100, 10)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; 0 in multi_signal</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; 0.5 in multi_signal</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; 1000 in multi_signal</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">first_item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No underlying &quot;Signal&quot; defined!&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSignal.__eq__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the multi-continuous signal is equal to given other</span>
<span class="sd">        object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            Object to test whether it is equal to multi-continuous signal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Is given object equal to the multi-continuous signal.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; range_ = np.linspace(10, 100, 10)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2 = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 == multi_signal_2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2[0] = 20</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 == multi_signal_2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2[0] = 10</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 == multi_signal_2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; from colour.algebra import CubicSplineInterpolator</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2.interpolator = CubicSplineInterpolator</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 == multi_signal_2</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiSignal</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">domain</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">range</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">interpolator</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">interpolator_args</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">interpolator_args</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extrapolator</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">extrapolator</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">extrapolator_args</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">extrapolator_args</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">labels</span>
            <span class="p">]):</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="MultiSignal.__ne__"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the multi-continuous signal is not equal to given other</span>
<span class="sd">        object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            Object to test whether it is not equal to the multi-continuous</span>
<span class="sd">            signal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Is given object not equal to the multi-continuous signal.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; range_ = np.linspace(10, 100, 10)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2 = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 != multi_signal_2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2[0] = 20</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 != multi_signal_2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2[0] = 10</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 != multi_signal_2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; from colour.algebra import CubicSplineInterpolator</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_2.interpolator = CubicSplineInterpolator</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 != multi_signal_2</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiSignal.arithmetical_operation"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.arithmetical_operation">[docs]</a>    <span class="k">def</span> <span class="nf">arithmetical_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs given arithmetical operation with :math:`a` operand, the</span>
<span class="sd">        operation can be either performed on a copy or in-place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : numeric or ndarray or Signal</span>
<span class="sd">            Operand.</span>
<span class="sd">        operation : object</span>
<span class="sd">            Operation to perform.</span>
<span class="sd">        in_place : bool, optional</span>
<span class="sd">            Operation happens in place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultiSignal</span>
<span class="sd">            Multi-continuous signal.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Adding a single *numeric* variable:</span>

<span class="sd">        &gt;&gt;&gt; domain = np.arange(0, 10, 1)</span>
<span class="sd">        &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal_1 = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal_1)</span>
<span class="sd">        [[   0.   10.   20.   30.]</span>
<span class="sd">         [   1.   20.   30.   40.]</span>
<span class="sd">         [   2.   30.   40.   50.]</span>
<span class="sd">         [   3.   40.   50.   60.]</span>
<span class="sd">         [   4.   50.   60.   70.]</span>
<span class="sd">         [   5.   60.   70.   80.]</span>
<span class="sd">         [   6.   70.   80.   90.]</span>
<span class="sd">         [   7.   80.   90.  100.]</span>
<span class="sd">         [   8.   90.  100.  110.]</span>
<span class="sd">         [   9.  100.  110.  120.]]</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal_1.arithmetical_operation(10, &#39;+&#39;, True))</span>
<span class="sd">        [[   0.   20.   30.   40.]</span>
<span class="sd">         [   1.   30.   40.   50.]</span>
<span class="sd">         [   2.   40.   50.   60.]</span>
<span class="sd">         [   3.   50.   60.   70.]</span>
<span class="sd">         [   4.   60.   70.   80.]</span>
<span class="sd">         [   5.   70.   80.   90.]</span>
<span class="sd">         [   6.   80.   90.  100.]</span>
<span class="sd">         [   7.   90.  100.  110.]</span>
<span class="sd">         [   8.  100.  110.  120.]</span>
<span class="sd">         [   9.  110.  120.  130.]]</span>

<span class="sd">        Adding an *array_like* variable:</span>

<span class="sd">        &gt;&gt;&gt; a = np.linspace(10, 100, 10)</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal_1.arithmetical_operation(a, &#39;+&#39;, True))</span>
<span class="sd">        [[   0.   30.   40.   50.]</span>
<span class="sd">         [   1.   50.   60.   70.]</span>
<span class="sd">         [   2.   70.   80.   90.]</span>
<span class="sd">         [   3.   90.  100.  110.]</span>
<span class="sd">         [   4.  110.  120.  130.]</span>
<span class="sd">         [   5.  130.  140.  150.]</span>
<span class="sd">         [   6.  150.  160.  170.]</span>
<span class="sd">         [   7.  170.  180.  190.]</span>
<span class="sd">         [   8.  190.  200.  210.]</span>
<span class="sd">         [   9.  210.  220.  230.]]</span>

<span class="sd">        &gt;&gt;&gt; a = np.array([[10, 20, 30]])</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal_1.arithmetical_operation(a, &#39;+&#39;, True))</span>
<span class="sd">        [[   0.   40.   60.   80.]</span>
<span class="sd">         [   1.   60.   80.  100.]</span>
<span class="sd">         [   2.   80.  100.  120.]</span>
<span class="sd">         [   3.  100.  120.  140.]</span>
<span class="sd">         [   4.  120.  140.  160.]</span>
<span class="sd">         [   5.  140.  160.  180.]</span>
<span class="sd">         [   6.  160.  180.  200.]</span>
<span class="sd">         [   7.  180.  200.  220.]</span>
<span class="sd">         [   8.  200.  220.  240.]</span>
<span class="sd">         [   9.  220.  240.  260.]]</span>

<span class="sd">        &gt;&gt;&gt; a = np.arange(0, 30, 1).reshape((10, 3))</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal_1.arithmetical_operation(a, &#39;+&#39;, True))</span>
<span class="sd">        [[   0.   40.   61.   82.]</span>
<span class="sd">         [   1.   63.   84.  105.]</span>
<span class="sd">         [   2.   86.  107.  128.]</span>
<span class="sd">         [   3.  109.  130.  151.]</span>
<span class="sd">         [   4.  132.  153.  174.]</span>
<span class="sd">         [   5.  155.  176.  197.]</span>
<span class="sd">         [   6.  178.  199.  220.]</span>
<span class="sd">         [   7.  201.  222.  243.]</span>
<span class="sd">         [   8.  224.  245.  266.]</span>
<span class="sd">         [   9.  247.  268.  289.]]</span>

<span class="sd">        Adding a :class:`colour.continuous.Signal` sub-class:</span>

<span class="sd">        &gt;&gt;&gt; multi_signal_2 = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal_1.arithmetical_operation(</span>
<span class="sd">        ...     multi_signal_2, &#39;+&#39;, True))</span>
<span class="sd">        [[   0.   50.   81.  112.]</span>
<span class="sd">         [   1.   83.  114.  145.]</span>
<span class="sd">         [   2.  116.  147.  178.]</span>
<span class="sd">         [   3.  149.  180.  211.]</span>
<span class="sd">         [   4.  182.  213.  244.]</span>
<span class="sd">         [   5.  215.  246.  277.]</span>
<span class="sd">         [   6.  248.  279.  310.]</span>
<span class="sd">         [   7.  281.  312.  343.]</span>
<span class="sd">         [   8.  314.  345.  376.]</span>
<span class="sd">         [   9.  347.  378.  409.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">multi_signal</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">in_place</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MultiSignal</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">signals</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;&quot;MultiSignal&quot; operands must have same count than &#39;</span>
                <span class="s1">&#39;underlying &quot;Signal&quot; components!&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">signal_a</span><span class="p">,</span> <span class="n">signal_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_signal</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                                          <span class="n">a</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">signal_a</span><span class="o">.</span><span class="n">arithmetical_operation</span><span class="p">(</span><span class="n">signal_b</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;Operand &quot;a&quot; variable must be a numeric or a 1-dimensional or &#39;</span>
                <span class="s1">&#39;2-dimensional array!&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">multi_signal</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">signal</span><span class="o">.</span><span class="n">arithmetical_operation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_signal</span><span class="o">.</span><span class="n">signals</span><span class="p">),</span> <span class="p">(</span>
                    <span class="s1">&#39;Operand &quot;a&quot; variable columns must have same count than &#39;</span>
                    <span class="s1">&#39;underlying &quot;Signal&quot; components!&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">signal</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_signal</span><span class="o">.</span><span class="n">signals</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">tsplit</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
                    <span class="n">signal</span><span class="o">.</span><span class="n">arithmetical_operation</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi_signal</span></div>

<div class="viewcode-block" id="MultiSignal.multi_signal_unpack_data"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.multi_signal_unpack_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">multi_signal_unpack_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">DEFAULT_FLOAT_DTYPE</span><span class="p">,</span>
                                 <span class="n">signal_type</span><span class="o">=</span><span class="n">Signal</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpack given data for multi-continuous signal instantiation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Series or Dataframe or Signal or MultiSignal or array_like or \</span>
<span class="sd">dict_like, optional</span>
<span class="sd">            Data to unpack for multi-continuous signal instantiation.</span>
<span class="sd">        domain : array_like, optional</span>
<span class="sd">            Values to initialise the multiple :class:`colour.continuous.Signal`</span>
<span class="sd">            sub-class instances :attr:`colour.continuous.Signal.domain`</span>
<span class="sd">            attribute with. If both ``data`` and ``domain`` arguments are</span>
<span class="sd">            defined, the latter will be used to initialise the</span>
<span class="sd">            :attr:`colour.continuous.Signal.domain` attribute.</span>
<span class="sd">        dtype : type, optional</span>
<span class="sd">            **{np.float16, np.float32, np.float64, np.float128}**,</span>
<span class="sd">            Floating point data type.</span>
<span class="sd">        signal_type : type, optional</span>
<span class="sd">            A :class:`colour.continuous.Signal` sub-class type.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        name : unicode, optional</span>
<span class="sd">            Multi-continuous signal name.</span>
<span class="sd">        interpolator : object, optional</span>
<span class="sd">            Interpolator class type to use as interpolating function for the</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">        interpolator_args : dict_like, optional</span>
<span class="sd">            Arguments to use when instantiating the interpolating function</span>
<span class="sd">            of the :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">        extrapolator : object, optional</span>
<span class="sd">            Extrapolator class type to use as extrapolating function for the</span>
<span class="sd">            :class:`colour.continuous.Signal` sub-class instances.</span>
<span class="sd">        extrapolator_args : dict_like, optional</span>
<span class="sd">            Arguments to use when instantiating the extrapolating function</span>
<span class="sd">            of the :class:`colour.continuous.Signal` sub-class instances.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Mapping of labeled :class:`colour.continuous.Signal` sub-class</span>
<span class="sd">            instances.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Unpacking using implicit *domain* and a single signal:</span>

<span class="sd">        &gt;&gt;&gt; range_ = np.linspace(10, 100, 10)</span>
<span class="sd">        &gt;&gt;&gt; signals = MultiSignal.multi_signal_unpack_data(range_)</span>
<span class="sd">        &gt;&gt;&gt; list(signals.keys())</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; print(signals[0])</span>
<span class="sd">        [[   0.   10.]</span>
<span class="sd">         [   1.   20.]</span>
<span class="sd">         [   2.   30.]</span>
<span class="sd">         [   3.   40.]</span>
<span class="sd">         [   4.   50.]</span>
<span class="sd">         [   5.   60.]</span>
<span class="sd">         [   6.   70.]</span>
<span class="sd">         [   7.   80.]</span>
<span class="sd">         [   8.   90.]</span>
<span class="sd">         [   9.  100.]]</span>

<span class="sd">        Unpacking using explicit *domain* and a single signal:</span>

<span class="sd">        &gt;&gt;&gt; domain = np.arange(100, 1100, 100)</span>
<span class="sd">        &gt;&gt;&gt; signals = MultiSignal.multi_signal_unpack_data(range_, domain)</span>
<span class="sd">        &gt;&gt;&gt; list(signals.keys())</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; print(signals[0])</span>
<span class="sd">        [[  100.    10.]</span>
<span class="sd">         [  200.    20.]</span>
<span class="sd">         [  300.    30.]</span>
<span class="sd">         [  400.    40.]</span>
<span class="sd">         [  500.    50.]</span>
<span class="sd">         [  600.    60.]</span>
<span class="sd">         [  700.    70.]</span>
<span class="sd">         [  800.    80.]</span>
<span class="sd">         [  900.    90.]</span>
<span class="sd">         [ 1000.   100.]]</span>

<span class="sd">        Unpacking using multiple signals:</span>

<span class="sd">        &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">        &gt;&gt;&gt; signals = MultiSignal.multi_signal_unpack_data(range_, domain)</span>
<span class="sd">        &gt;&gt;&gt; list(signals.keys())</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; print(signals[2])</span>
<span class="sd">        [[  100.    30.]</span>
<span class="sd">         [  200.    40.]</span>
<span class="sd">         [  300.    50.]</span>
<span class="sd">         [  400.    60.]</span>
<span class="sd">         [  500.    70.]</span>
<span class="sd">         [  600.    80.]</span>
<span class="sd">         [  700.    90.]</span>
<span class="sd">         [  800.   100.]</span>
<span class="sd">         [  900.   110.]</span>
<span class="sd">         [ 1000.   120.]]</span>

<span class="sd">        Unpacking using a *dict*:</span>

<span class="sd">        &gt;&gt;&gt; signals = MultiSignal.multi_signal_unpack_data(</span>
<span class="sd">        ...     dict(zip(domain, range_)))</span>
<span class="sd">        &gt;&gt;&gt; list(signals.keys())</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; print(signals[2])</span>
<span class="sd">        [[  100.    30.]</span>
<span class="sd">         [  200.    40.]</span>
<span class="sd">         [  300.    50.]</span>
<span class="sd">         [  400.    60.]</span>
<span class="sd">         [  500.    70.]</span>
<span class="sd">         [  600.    80.]</span>
<span class="sd">         [  700.    90.]</span>
<span class="sd">         [  800.   100.]</span>
<span class="sd">         [  900.   110.]</span>
<span class="sd">         [ 1000.   120.]]</span>

<span class="sd">        Unpacking using *MultiSignal.multi_signal_unpack_data* method output:</span>

<span class="sd">        &gt;&gt;&gt; signals = MultiSignal.multi_signal_unpack_data(</span>
<span class="sd">        ...     dict(zip(domain, range_)))</span>
<span class="sd">        &gt;&gt;&gt; signals = MultiSignal.multi_signal_unpack_data(signals)</span>
<span class="sd">        &gt;&gt;&gt; list(signals.keys())</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; print(signals[2])</span>
<span class="sd">        [[  100.    30.]</span>
<span class="sd">         [  200.    40.]</span>
<span class="sd">         [  300.    50.]</span>
<span class="sd">         [  400.    60.]</span>
<span class="sd">         [  500.    70.]</span>
<span class="sd">         [  600.    80.]</span>
<span class="sd">         [  700.    90.]</span>
<span class="sd">         [  800.   100.]</span>
<span class="sd">         [  900.   110.]</span>
<span class="sd">         [ 1000.   120.]]</span>

<span class="sd">        Unpacking using a *Pandas* *Series*:</span>

<span class="sd">        &gt;&gt;&gt; if is_pandas_installed():</span>
<span class="sd">        ...     from pandas import Series</span>
<span class="sd">        ...     signals = MultiSignal.multi_signal_unpack_data(</span>
<span class="sd">        ...         Series(dict(zip(domain, np.linspace(10, 100, 10)))))</span>
<span class="sd">        ...     print(signals[0])  # doctest: +SKIP</span>
<span class="sd">        [[  100.    10.]</span>
<span class="sd">         [  200.    20.]</span>
<span class="sd">         [  300.    30.]</span>
<span class="sd">         [  400.    40.]</span>
<span class="sd">         [  500.    50.]</span>
<span class="sd">         [  600.    60.]</span>
<span class="sd">         [  700.    70.]</span>
<span class="sd">         [  800.    80.]</span>
<span class="sd">         [  900.    90.]</span>
<span class="sd">         [ 1000.   100.]]</span>

<span class="sd">        Unpacking using a *Pandas* *Dataframe*:</span>

<span class="sd">        &gt;&gt;&gt; if is_pandas_installed():</span>
<span class="sd">        ...     from pandas import DataFrame</span>
<span class="sd">        ...     data = dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], tsplit(range_)))</span>
<span class="sd">        ...     signals = MultiSignal.multi_signal_unpack_data(</span>
<span class="sd">        ...         DataFrame(data, domain))</span>
<span class="sd">        ...     print(signals[&#39;c&#39;])  # doctest: +SKIP</span>
<span class="sd">        [[  100.    30.]</span>
<span class="sd">         [  200.    40.]</span>
<span class="sd">         [  300.    50.]</span>
<span class="sd">         [  400.    60.]</span>
<span class="sd">         [  500.    70.]</span>
<span class="sd">         [  600.    80.]</span>
<span class="sd">         [  700.    90.]</span>
<span class="sd">         [  800.   100.]</span>
<span class="sd">         [  900.   110.]</span>
<span class="sd">         [ 1000.   120.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sctypes</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">],</span> <span class="p">(</span>
            <span class="s1">&#39;&quot;dtype&quot; must be one of the following types: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sctypes</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">]))</span>

        <span class="n">domain_u</span><span class="p">,</span> <span class="n">range_u</span><span class="p">,</span> <span class="n">signals</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">signals</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># TODO: Implement support for Signal class passing.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">MultiSignal</span><span class="p">):</span>
            <span class="n">signals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">signals</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">or</span>
              <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">))):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">tsplit</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">)</span> <span class="k">else</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;User &quot;data&quot; must be 1-dimensional or 2-dimensional!&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">range_u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal_type</span><span class="p">(</span><span class="n">range_u</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">Mapping</span><span class="p">)</span> <span class="ow">or</span>
              <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">))):</span>

            <span class="c1"># Handling `MultiSignal.multi_signal_unpack_data` method output</span>
            <span class="c1"># used as argument to `MultiSignal.multi_signal_unpack_data`</span>
            <span class="c1"># method.</span>
            <span class="n">is_signal</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span>
                <span class="kc">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Signal</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">])</span>

            <span class="k">if</span> <span class="n">is_signal</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">signals</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal_type</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">domain_u</span><span class="p">,</span> <span class="n">range_u</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">range_u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tsplit</span><span class="p">(</span><span class="n">range_u</span><span class="p">)):</span>
                    <span class="n">signals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal_type</span><span class="p">(</span><span class="n">range_u</span><span class="p">,</span> <span class="n">domain_u</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_pandas_installed</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal_type</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">domain_u</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
                <span class="n">signals</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(((</span><span class="n">label</span><span class="p">,</span> <span class="n">signal_type</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="n">domain_u</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                                       <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">data</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">signals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">domain</span><span class="p">),</span> <span class="p">(</span>
                    <span class="s1">&#39;User &quot;domain&quot; is not compatible with unpacked signals!&#39;</span><span class="p">)</span>
                <span class="n">signal</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">signals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">signals</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;User &quot;labels&quot; is not compatible with unpacked signals!&#39;</span><span class="p">)</span>
            <span class="n">signals</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">signal</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">signals</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>

        <span class="k">return</span> <span class="n">signals</span></div>

<div class="viewcode-block" id="MultiSignal.fill_nan"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.fill_nan">[docs]</a>    <span class="k">def</span> <span class="nf">fill_nan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Interpolation&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NaNs in independent domain :math:`x` variable and corresponding</span>
<span class="sd">        range :math:`y` variable using given method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : unicode, optional</span>
<span class="sd">            **{&#39;Interpolation&#39;, &#39;Constant&#39;}**,</span>
<span class="sd">            *Interpolation* method linearly interpolates through the NaNs,</span>
<span class="sd">            *Constant* method replaces NaNs with ``default``.</span>
<span class="sd">        default : numeric, optional</span>
<span class="sd">            Value to use with the *Constant* method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Signal</span>
<span class="sd">            NaNs filled multi-continuous signal.</span>

<span class="sd">        &gt;&gt;&gt; domain = np.arange(0, 10, 1)</span>
<span class="sd">        &gt;&gt;&gt; range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        &gt;&gt;&gt; range_ += np.array([0, 10, 20])</span>
<span class="sd">        &gt;&gt;&gt; multi_signal = MultiSignal(range_)</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[3:7] = np.nan</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal)</span>
<span class="sd">        [[   0.   10.   20.   30.]</span>
<span class="sd">         [   1.   20.   30.   40.]</span>
<span class="sd">         [   2.   30.   40.   50.]</span>
<span class="sd">         [   3.   nan   nan   nan]</span>
<span class="sd">         [   4.   nan   nan   nan]</span>
<span class="sd">         [   5.   nan   nan   nan]</span>
<span class="sd">         [   6.   nan   nan   nan]</span>
<span class="sd">         [   7.   80.   90.  100.]</span>
<span class="sd">         [   8.   90.  100.  110.]</span>
<span class="sd">         [   9.  100.  110.  120.]]</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal.fill_nan())</span>
<span class="sd">        [[   0.   10.   20.   30.]</span>
<span class="sd">         [   1.   20.   30.   40.]</span>
<span class="sd">         [   2.   30.   40.   50.]</span>
<span class="sd">         [   3.   40.   50.   60.]</span>
<span class="sd">         [   4.   50.   60.   70.]</span>
<span class="sd">         [   5.   60.   70.   80.]</span>
<span class="sd">         [   6.   70.   80.   90.]</span>
<span class="sd">         [   7.   80.   90.  100.]</span>
<span class="sd">         [   8.   90.  100.  110.]</span>
<span class="sd">         [   9.  100.  110.  120.]]</span>
<span class="sd">        &gt;&gt;&gt; multi_signal[3:7] = np.nan</span>
<span class="sd">        &gt;&gt;&gt; print(multi_signal.fill_nan(method=&#39;Constant&#39;))</span>
<span class="sd">        [[   0.   10.   20.   30.]</span>
<span class="sd">         [   1.   20.   30.   40.]</span>
<span class="sd">         [   2.   30.   40.   50.]</span>
<span class="sd">         [   3.    0.    0.    0.]</span>
<span class="sd">         [   4.    0.    0.    0.]</span>
<span class="sd">         [   5.    0.    0.    0.]</span>
<span class="sd">         [   6.    0.    0.    0.]</span>
<span class="sd">         [   7.   80.   90.  100.]</span>
<span class="sd">         [   8.   90.  100.  110.]</span>
<span class="sd">         [   9.  100.  110.  120.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_signals</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">signal</span><span class="o">.</span><span class="n">fill_nan</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MultiSignal.to_dataframe"><a class="viewcode-back" href="../../../generated/colour.continuous.MultiSignal.html#colour.continuous.MultiSignal.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the continuous signal to a *Pandas* :class:`DataFrame` class</span>
<span class="sd">        instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Continuous signal as a *Pandas* :class:`DataFrame` class instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; if is_pandas_installed():</span>
<span class="sd">        ...     domain = np.arange(0, 10, 1)</span>
<span class="sd">        ...     range_ = tstack([np.linspace(10, 100, 10)] * 3)</span>
<span class="sd">        ...     range_ += np.array([0, 10, 20])</span>
<span class="sd">        ...     multi_signal = MultiSignal(range_)</span>
<span class="sd">        ...     print(multi_signal.to_dataframe())  # doctest: +SKIP</span>
<span class="sd">                 0      1      2</span>
<span class="sd">        0.0   10.0   20.0   30.0</span>
<span class="sd">        1.0   20.0   30.0   40.0</span>
<span class="sd">        2.0   30.0   40.0   50.0</span>
<span class="sd">        3.0   40.0   50.0   60.0</span>
<span class="sd">        4.0   50.0   60.0   70.0</span>
<span class="sd">        5.0   60.0   70.0   80.0</span>
<span class="sd">        6.0   70.0   80.0   90.0</span>
<span class="sd">        7.0   80.0   90.0  100.0</span>
<span class="sd">        8.0   90.0  100.0  110.0</span>
<span class="sd">        9.0  100.0  110.0  120.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">is_pandas_installed</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>

            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright  2013-2018 - Colour Developers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.3.11',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>