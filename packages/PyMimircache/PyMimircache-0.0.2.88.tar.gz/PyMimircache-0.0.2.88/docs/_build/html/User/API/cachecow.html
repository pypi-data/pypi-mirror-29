
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>API-cachecow &#8212; PyMimircache v0.0.2.88</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.0.2.88',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="API-profiler" href="profiler.html" />
    <link rel="prev" title="API" href="../API.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="profiler.html" title="API-profiler"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../API.html" title="API"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyMimircache v0.0.2.88</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../API.html" accesskey="U">API</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="../API.html"
                        title="previous chapter">API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="profiler.html"
                        title="next chapter">API-profiler</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/User/API/cachecow.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-PyMimircache.top.cachecow">
<span id="id1"></span><span id="api-cachecow"></span><h1>API-cachecow<a class="headerlink" href="#module-PyMimircache.top.cachecow" title="Permalink to this headline">¶</a></h1>
<p>this module offer the upper level API to user, it currently supports four types of operations,</p>
<ul class="simple">
<li><strong>trace loading</strong></li>
<li><strong>trace information retrieving</strong></li>
<li><strong>trace profiling</strong></li>
<li><strong>plotting</strong></li>
</ul>
<p>Author: Jason Yang &lt;<a class="reference external" href="mailto:peter&#46;waynechina&#37;&#52;&#48;gmail&#46;com">peter<span>&#46;</span>waynechina<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt; 2017/08</p>
<dl class="class">
<dt id="PyMimircache.top.cachecow.Cachecow">
<em class="property">class </em><code class="descclassname">PyMimircache.top.cachecow.</code><code class="descname">Cachecow</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow" title="Permalink to this definition">¶</a></dt>
<dd><p>cachecow class providing top level API</p>
<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.open">
<code class="descname">open</code><span class="sig-paren">(</span><em>file_path</em>, <em>trace_type='p'</em>, <em>data_type='c'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.open" title="Permalink to this definition">¶</a></dt>
<dd><p>The default operation of this function opens a plain text trace,
the format of a plain text trace is such a file that each line contains a label.</p>
<p>By changing trace type, it can be used for opening other types of trace,
supported trace type includes</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="23%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">trace_type</th>
<th class="head">file type</th>
<th class="head">require init_params</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>“p”</td>
<td>plain text</td>
<td>No</td>
</tr>
<tr class="row-odd"><td>“c”</td>
<td>csv</td>
<td>Yes</td>
</tr>
<tr class="row-even"><td>“b”</td>
<td>binary</td>
<td>Yes</td>
</tr>
<tr class="row-odd"><td>“v”</td>
<td>vscsi</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>the effect of this is the save as calling corresponding functions (csv, binary, vscsi)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>trace_type</strong> – type of trace, “p” for plainText, “c” for csv, “v” for vscsi, “b” for binary</li>
<li><strong>data_type</strong> – the type of request label,                     can be either “c” for string or “l” for number (for example block IO LBA)</li>
<li><strong>kwargs</strong> – parameters for opening the trace</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.csv">
<code class="descname">csv</code><span class="sig-paren">(</span><em>file_path</em>, <em>init_params</em>, <em>data_type='c'</em>, <em>block_unit_size=0</em>, <em>disk_sector_size=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.csv" title="Permalink to this definition">¶</a></dt>
<dd><p>open a csv trace, init_params is a dictionary specifying the specs of the csv file,
the possible keys are listed in the table below.
The column/field number begins from 1, so the first column(field) is 1, the second is 2, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>init_params</strong> – params related to csv file, see above or csvReader for details</li>
<li><strong>data_type</strong> – the type of request label,                     can be either “c” for string or “l” for number (for example block IO LBA)</li>
<li><strong>block_unit_size</strong> – the block size for a cache, currently storage system only</li>
<li><strong>disk_sector_size</strong> – the disk sector size of input file, storage system only</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="11%" />
<col width="12%" />
<col width="18%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword Argument</th>
<th class="head">file type</th>
<th class="head">Value Type</th>
<th class="head">Default Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>label</td>
<td>csv/ binary</td>
<td>int</td>
<td>this is required</td>
<td>the column of the label of the request</td>
</tr>
<tr class="row-odd"><td>fmt</td>
<td>binary</td>
<td>string</td>
<td>this is required</td>
<td>fmt string of binary data, same as python struct</td>
</tr>
<tr class="row-even"><td>header</td>
<td>csv</td>
<td>True/False</td>
<td>False</td>
<td>whether csv data has header</td>
</tr>
<tr class="row-odd"><td>delimiter</td>
<td>csv</td>
<td>char</td>
<td>“,”</td>
<td>the delimiter separating fields in the csv file</td>
</tr>
<tr class="row-even"><td>real_time</td>
<td>csv/ binary</td>
<td>int</td>
<td>NA</td>
<td>the column of real time</td>
</tr>
<tr class="row-odd"><td>op</td>
<td>csv/ binary</td>
<td>int</td>
<td>NA</td>
<td>the column of operation (read/write)</td>
</tr>
<tr class="row-even"><td>size</td>
<td>csv/ binary</td>
<td>int</td>
<td>NA</td>
<td>the column of block/request size</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.binary">
<code class="descname">binary</code><span class="sig-paren">(</span><em>file_path</em>, <em>init_params</em>, <em>data_type='l'</em>, <em>block_unit_size=0</em>, <em>disk_sector_size=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>open a binary trace file, init_params see function csv</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>init_params</strong> – params related to the spec of data, see above csv for details</li>
<li><strong>data_type</strong> – the type of request label,                     can be either “c” for string or “l” for number (for example block IO LBA)</li>
<li><strong>block_unit_size</strong> – the block size for a cache, currently storage system only</li>
<li><strong>disk_sector_size</strong> – the disk sector size of input file, storage system only</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.vscsi">
<code class="descname">vscsi</code><span class="sig-paren">(</span><em>file_path</em>, <em>block_unit_size=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.vscsi" title="Permalink to this definition">¶</a></dt>
<dd><p>open vscsi trace file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>block_unit_size</strong> – the block size for a cache, currently storage system only</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.reset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>reset cachecow to initial state, including</dt>
<dd>reset reader to the beginning of the trace</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the reader opened in cachecow, and clean up in the future</p>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.stat">
<code class="descname">stat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.stat" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the statistical information about the trace, including</p>
<blockquote>
<div><ul class="simple">
<li>number of requests</li>
<li>number of uniq items</li>
<li>cold miss ratio</li>
<li>a list of top 10 popular in form of (obj, num of requests):</li>
<li>number of obj/block accessed only once</li>
<li>frequency mean</li>
<li>time span</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string of the information above</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.num_of_req">
<code class="descname">num_of_req</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.num_of_req" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of requests in the trace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.num_of_uniq_req">
<code class="descname">num_of_uniq_req</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.num_of_uniq_req" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of unique requests in the trace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.get_reuse_distance">
<code class="descname">get_reuse_distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.get_reuse_distance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array of reuse distance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.get_hit_count_dict">
<code class="descname">get_hit_count_dict</code><span class="sig-paren">(</span><em>algorithm</em>, <em>cache_size=-1</em>, <em>cache_params=None</em>, <em>bin_size=-1</em>, <em>use_general_profiler=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.get_hit_count_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>get hit count of the given algorithm and return a dict of mapping from cache size -&gt; hit count
notice that hit count array is not CDF, meaning hit count of size 2 does not include hit count of size 1,
you need to sum up to get a CDF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>algorithm</strong> – cache replacement algorithms</li>
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>cache_params</strong> – parameters passed to cache, some of the cache replacement algorithms require parameters,
for example LRU-K, SLRU</li>
<li><strong>bin_size</strong> – if algorithm is not LRU, then the hit ratio will be calculated by simulating cache at
cache size [0, bin_size, bin_size*2 … cache_size], this is not required for LRU</li>
<li><strong>use_general_profiler</strong> – if algorithm is LRU and you don’t want to use LRUProfiler, then set this to True,
possible reason for not using a LRUProfiler: 1. LRUProfiler is too slow for your large trace
because the algorithm is O(NlogN) and it uses single thread; 2. LRUProfiler has a bug (let me know if you found a bug).</li>
<li><strong>kwargs</strong> – other parameters including num_of_threads</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an dict of hit ratio of given algorithms, mapping from cache_size -&gt; hit ratio</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.get_hit_ratio_dict">
<code class="descname">get_hit_ratio_dict</code><span class="sig-paren">(</span><em>algorithm</em>, <em>cache_size=-1</em>, <em>cache_params=None</em>, <em>bin_size=-1</em>, <em>use_general_profiler=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.get_hit_ratio_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>get hit ratio of the given algorithm and return a dict of mapping from cache size -&gt; hit ratio</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>algorithm</strong> – cache replacement algorithms</li>
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>cache_params</strong> – parameters passed to cache, some of the cache replacement algorithms require parameters,
for example LRU-K, SLRU</li>
<li><strong>bin_size</strong> – if algorithm is not LRU, then the hit ratio will be calculated by simulating cache at
cache size [0, bin_size, bin_size*2 … cache_size], this is not required for LRU</li>
<li><strong>use_general_profiler</strong> – if algorithm is LRU and you don’t want to use LRUProfiler, then set this to True,
possible reason for not using a LRUProfiler: 1. LRUProfiler is too slow for your large trace
because the algorithm is O(NlogN) and it uses single thread; 2. LRUProfiler has a bug (let me know if you found a bug).</li>
<li><strong>kwargs</strong> – other parameters including num_of_threads</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an dict of hit ratio of given algorithms, mapping from cache_size -&gt; hit ratio</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.profiler">
<code class="descname">profiler</code><span class="sig-paren">(</span><em>algorithm</em>, <em>cache_params=None</em>, <em>cache_size=-1</em>, <em>bin_size=-1</em>, <em>use_general_profiler=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.profiler" title="Permalink to this definition">¶</a></dt>
<dd><p>get a profiler instance, this should not be used by most users</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>algorithm</strong> – name of algorithm</li>
<li><strong>cache_params</strong> – parameters of given cache replacement algorithm</li>
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>bin_size</strong> – bin_size for generalProfiler</li>
<li><strong>use_general_profiler</strong> – <p>this option is for LRU only, if it is True,
then return a cGeneralProfiler for LRU,
otherwise, return a LRUProfiler for LRU.</p>
<p>Note: LRUProfiler does not require cache_size/bin_size params,
it does not sample thus provides a smooth curve, however, it is O(logN) at each step,
in constrast, cGeneralProfiler samples the curve, but use O(1) at each step</p>
</li>
<li><strong>kwargs</strong> – num_of_threads</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a profiler instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.heatmap">
<code class="descname">heatmap</code><span class="sig-paren">(</span><em>time_mode</em>, <em>plot_type</em>, <em>time_interval=-1</em>, <em>num_of_pixels=-1</em>, <em>algorithm='LRU'</em>, <em>cache_params=None</em>, <em>cache_size=-1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.heatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>plot heatmaps, currently supports the following heatmaps</p>
<ul class="simple">
<li>hit_ratio_start_time_end_time</li>
<li>hit_ratio_start_time_cache_size (python only)</li>
<li>avg_rd_start_time_end_time (python only)</li>
<li>cold_miss_count_start_time_end_time (python only)</li>
<li>rd_distribution</li>
<li>rd_distribution_CDF</li>
<li>future_rd_distribution</li>
<li>dist_distribution</li>
<li>reuse_time_distribution</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_mode</strong> – the type of time, can be “v” for virtual time, or “r” for real time</li>
<li><strong>plot_type</strong> – the name of plot types, see above for plot types</li>
<li><strong>time_interval</strong> – the time interval of one pixel</li>
<li><strong>num_of_pixels</strong> – if you don’t to use time_interval,
you can also specify how many pixels you want in one dimension,
note this feature is not well tested</li>
<li><strong>algorithm</strong> – what algorithm to use for plotting heatmap,
this is not required for distance related heatmap like rd_distribution</li>
<li><strong>cache_params</strong> – parameters passed to cache, some of the cache replacement algorithms require parameters,
for example LRU-K, SLRU</li>
<li><strong>cache_size</strong> – The size of cache, this is required only for <em>hit_ratio_start_time_end_time</em></li>
<li><strong>kwargs</strong> – other parameters for computation and plotting such as num_of_threads, figname</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.diff_heatmap">
<code class="descname">diff_heatmap</code><span class="sig-paren">(</span><em>time_mode</em>, <em>plot_type</em>, <em>algorithm1</em>, <em>time_interval=-1</em>, <em>num_of_pixels=-1</em>, <em>algorithm2='Optimal'</em>, <em>cache_params1=None</em>, <em>cache_params2=None</em>, <em>cache_size=-1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.diff_heatmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the differential heatmap between two algorithms by alg2 - alg1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>time_mode</strong> – time time_mode “v” for virutal time, “r” for real time</li>
<li><strong>plot_type</strong> – same as the name in heatmap function</li>
<li><strong>algorithm1</strong> – name of the first alg</li>
<li><strong>time_interval</strong> – same as in heatmap</li>
<li><strong>num_of_pixels</strong> – same as in heatmap</li>
<li><strong>algorithm2</strong> – name of the second algorithm</li>
<li><strong>cache_params1</strong> – parameters of the first algorithm</li>
<li><strong>cache_params2</strong> – parameters of the second algorithm</li>
<li><strong>kwargs</strong> – include num_of_threads</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.twoDPlot">
<code class="descname">twoDPlot</code><span class="sig-paren">(</span><em>plot_type</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.twoDPlot" title="Permalink to this definition">¶</a></dt>
<dd><p>an aggregate function for all two dimenional plots printing except hit ratio curve</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="28%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">plot type</th>
<th class="head">required parameters</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>cold_miss_count</td>
<td>time_mode, time_interval</td>
<td>cold miss count VS time</td>
</tr>
<tr class="row-odd"><td>cold_miss_ratio</td>
<td>time_mode, time_interval</td>
<td>coid miss ratio VS time</td>
</tr>
<tr class="row-even"><td>request_rate</td>
<td>time_mode, time_interval</td>
<td>num of requests VS time</td>
</tr>
<tr class="row-odd"><td>popularity</td>
<td>NA</td>
<td>Percentage of obj VS frequency</td>
</tr>
<tr class="row-even"><td>rd_popularity</td>
<td>NA</td>
<td>Num of req VS reuse distance</td>
</tr>
<tr class="row-odd"><td>rt_popularity</td>
<td>NA</td>
<td>Num of req VS reuse time</td>
</tr>
<tr class="row-even"><td>mapping</td>
<td>NA</td>
<td>mapping from original objID to sequential number</td>
</tr>
<tr class="row-odd"><td>interval_hit_ratio</td>
<td>cache_size</td>
<td>hit ratio of interval VS time</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>plot_type</strong> – type of the plot, see above</li>
<li><strong>kwargs</strong> – paramters related to plots, see twoDPlots module for detailed control over plots</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.plotHRCs">
<code class="descname">plotHRCs</code><span class="sig-paren">(</span><em>algorithm_list</em>, <em>cache_params=()</em>, <em>cache_size=-1</em>, <em>bin_size=-1</em>, <em>auto_resize=True</em>, <em>figname='HRC.png'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.plotHRCs" title="Permalink to this definition">¶</a></dt>
<dd><p>this function provides hit ratio curve plotting</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>algorithm_list</strong> – a list of algorithm(s)</li>
<li><strong>cache_params</strong> – the corresponding cache params for the algorithms,
use None for algorithms that don’t require cache params,
if none of the alg requires cache params, you don’t need to set this</li>
<li><strong>cache_size</strong> – maximal size of cache, use -1 for max possible size</li>
<li><strong>bin_size</strong> – bin size for non-LRU profiling</li>
<li><strong>auto_resize</strong> – when using max possible size or specified cache size too large,
you will get a huge plateau at the end of hit ratio curve,
set auto_resize to True to cutoff most of the big plateau</li>
<li><strong>figname</strong> – name of figure</li>
<li><strong>kwargs</strong> – <p>options: block_unit_size, num_of_threads,
auto_resize_threshold, xlimit, ylimit, cache_unit_size</p>
<p>save_gradually - save a figure everytime computation for one algorithm finishes,</p>
<p>label - instead of using algorithm list as label, specify user-defined label</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PyMimircache.top.cachecow.Cachecow.characterize">
<code class="descname">characterize</code><span class="sig-paren">(</span><em>characterize_type</em>, <em>cache_size=-1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#PyMimircache.top.cachecow.Cachecow.characterize" title="Permalink to this definition">¶</a></dt>
<dd><p>use this function to obtain a series of plots about your trace, the type includes</p>
<ul class="simple">
<li>short - short run time, fewer plots with less accuracy</li>
<li>medium</li>
<li>long</li>
<li>all - most of the available plots with high accuracy, notice it can take <strong>LONG</strong> time on big trace</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>characterize_type</strong> – see above, options: short, medium, long, all</li>
<li><strong>cache_size</strong> – estimated cache size for the trace, if -1, PyMimircache will estimate the cache size</li>
<li><strong>kwargs</strong> – print_stat</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">trace stat string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">PyMimircache.top.cachecow.</code><code class="descname">Cachecow</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>cachecow class providing top level API</p>
<dl class="method">
<dt>
<code class="descname">open</code><span class="sig-paren">(</span><em>file_path</em>, <em>trace_type='p'</em>, <em>data_type='c'</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>The default operation of this function opens a plain text trace,
the format of a plain text trace is such a file that each line contains a label.</p>
<p>By changing trace type, it can be used for opening other types of trace,
supported trace type includes</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="23%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">trace_type</th>
<th class="head">file type</th>
<th class="head">require init_params</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>“p”</td>
<td>plain text</td>
<td>No</td>
</tr>
<tr class="row-odd"><td>“c”</td>
<td>csv</td>
<td>Yes</td>
</tr>
<tr class="row-even"><td>“b”</td>
<td>binary</td>
<td>Yes</td>
</tr>
<tr class="row-odd"><td>“v”</td>
<td>vscsi</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>the effect of this is the save as calling corresponding functions (csv, binary, vscsi)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>trace_type</strong> – type of trace, “p” for plainText, “c” for csv, “v” for vscsi, “b” for binary</li>
<li><strong>data_type</strong> – the type of request label,                     can be either “c” for string or “l” for number (for example block IO LBA)</li>
<li><strong>kwargs</strong> – parameters for opening the trace</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">csv</code><span class="sig-paren">(</span><em>file_path</em>, <em>init_params</em>, <em>data_type='c'</em>, <em>block_unit_size=0</em>, <em>disk_sector_size=0</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>open a csv trace, init_params is a dictionary specifying the specs of the csv file,
the possible keys are listed in the table below.
The column/field number begins from 1, so the first column(field) is 1, the second is 2, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>init_params</strong> – params related to csv file, see above or csvReader for details</li>
<li><strong>data_type</strong> – the type of request label,                     can be either “c” for string or “l” for number (for example block IO LBA)</li>
<li><strong>block_unit_size</strong> – the block size for a cache, currently storage system only</li>
<li><strong>disk_sector_size</strong> – the disk sector size of input file, storage system only</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="11%" />
<col width="12%" />
<col width="18%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword Argument</th>
<th class="head">file type</th>
<th class="head">Value Type</th>
<th class="head">Default Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>label</td>
<td>csv/ binary</td>
<td>int</td>
<td>this is required</td>
<td>the column of the label of the request</td>
</tr>
<tr class="row-odd"><td>fmt</td>
<td>binary</td>
<td>string</td>
<td>this is required</td>
<td>fmt string of binary data, same as python struct</td>
</tr>
<tr class="row-even"><td>header</td>
<td>csv</td>
<td>True/False</td>
<td>False</td>
<td>whether csv data has header</td>
</tr>
<tr class="row-odd"><td>delimiter</td>
<td>csv</td>
<td>char</td>
<td>“,”</td>
<td>the delimiter separating fields in the csv file</td>
</tr>
<tr class="row-even"><td>real_time</td>
<td>csv/ binary</td>
<td>int</td>
<td>NA</td>
<td>the column of real time</td>
</tr>
<tr class="row-odd"><td>op</td>
<td>csv/ binary</td>
<td>int</td>
<td>NA</td>
<td>the column of operation (read/write)</td>
</tr>
<tr class="row-even"><td>size</td>
<td>csv/ binary</td>
<td>int</td>
<td>NA</td>
<td>the column of block/request size</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">binary</code><span class="sig-paren">(</span><em>file_path</em>, <em>init_params</em>, <em>data_type='l'</em>, <em>block_unit_size=0</em>, <em>disk_sector_size=0</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>open a binary trace file, init_params see function csv</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>init_params</strong> – params related to the spec of data, see above csv for details</li>
<li><strong>data_type</strong> – the type of request label,                     can be either “c” for string or “l” for number (for example block IO LBA)</li>
<li><strong>block_unit_size</strong> – the block size for a cache, currently storage system only</li>
<li><strong>disk_sector_size</strong> – the disk sector size of input file, storage system only</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">vscsi</code><span class="sig-paren">(</span><em>file_path</em>, <em>block_unit_size=0</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>open vscsi trace file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – the path to the data</li>
<li><strong>block_unit_size</strong> – the block size for a cache, currently storage system only</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">reader object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><dl class="docutils">
<dt>reset cachecow to initial state, including</dt>
<dd>reset reader to the beginning of the trace</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>close the reader opened in cachecow, and clean up in the future</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">stat</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>obtain the statistical information about the trace, including</p>
<blockquote>
<div><ul class="simple">
<li>number of requests</li>
<li>number of uniq items</li>
<li>cold miss ratio</li>
<li>a list of top 10 popular in form of (obj, num of requests):</li>
<li>number of obj/block accessed only once</li>
<li>frequency mean</li>
<li>time span</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string of the information above</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">num_of_req</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of requests in the trace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">num_of_uniq_req</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of unique requests in the trace</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_reuse_distance</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an array of reuse distance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_hit_count_dict</code><span class="sig-paren">(</span><em>algorithm</em>, <em>cache_size=-1</em>, <em>cache_params=None</em>, <em>bin_size=-1</em>, <em>use_general_profiler=False</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>get hit count of the given algorithm and return a dict of mapping from cache size -&gt; hit count
notice that hit count array is not CDF, meaning hit count of size 2 does not include hit count of size 1,
you need to sum up to get a CDF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>algorithm</strong> – cache replacement algorithms</li>
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>cache_params</strong> – parameters passed to cache, some of the cache replacement algorithms require parameters,
for example LRU-K, SLRU</li>
<li><strong>bin_size</strong> – if algorithm is not LRU, then the hit ratio will be calculated by simulating cache at
cache size [0, bin_size, bin_size*2 … cache_size], this is not required for LRU</li>
<li><strong>use_general_profiler</strong> – if algorithm is LRU and you don’t want to use LRUProfiler, then set this to True,
possible reason for not using a LRUProfiler: 1. LRUProfiler is too slow for your large trace
because the algorithm is O(NlogN) and it uses single thread; 2. LRUProfiler has a bug (let me know if you found a bug).</li>
<li><strong>kwargs</strong> – other parameters including num_of_threads</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an dict of hit ratio of given algorithms, mapping from cache_size -&gt; hit ratio</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_hit_ratio_dict</code><span class="sig-paren">(</span><em>algorithm</em>, <em>cache_size=-1</em>, <em>cache_params=None</em>, <em>bin_size=-1</em>, <em>use_general_profiler=False</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>get hit ratio of the given algorithm and return a dict of mapping from cache size -&gt; hit ratio</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>algorithm</strong> – cache replacement algorithms</li>
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>cache_params</strong> – parameters passed to cache, some of the cache replacement algorithms require parameters,
for example LRU-K, SLRU</li>
<li><strong>bin_size</strong> – if algorithm is not LRU, then the hit ratio will be calculated by simulating cache at
cache size [0, bin_size, bin_size*2 … cache_size], this is not required for LRU</li>
<li><strong>use_general_profiler</strong> – if algorithm is LRU and you don’t want to use LRUProfiler, then set this to True,
possible reason for not using a LRUProfiler: 1. LRUProfiler is too slow for your large trace
because the algorithm is O(NlogN) and it uses single thread; 2. LRUProfiler has a bug (let me know if you found a bug).</li>
<li><strong>kwargs</strong> – other parameters including num_of_threads</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">an dict of hit ratio of given algorithms, mapping from cache_size -&gt; hit ratio</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">profiler</code><span class="sig-paren">(</span><em>algorithm</em>, <em>cache_params=None</em>, <em>cache_size=-1</em>, <em>bin_size=-1</em>, <em>use_general_profiler=False</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>get a profiler instance, this should not be used by most users</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>algorithm</strong> – name of algorithm</li>
<li><strong>cache_params</strong> – parameters of given cache replacement algorithm</li>
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>bin_size</strong> – bin_size for generalProfiler</li>
<li><strong>use_general_profiler</strong> – <p>this option is for LRU only, if it is True,
then return a cGeneralProfiler for LRU,
otherwise, return a LRUProfiler for LRU.</p>
<p>Note: LRUProfiler does not require cache_size/bin_size params,
it does not sample thus provides a smooth curve, however, it is O(logN) at each step,
in constrast, cGeneralProfiler samples the curve, but use O(1) at each step</p>
</li>
<li><strong>kwargs</strong> – num_of_threads</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a profiler instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">heatmap</code><span class="sig-paren">(</span><em>time_mode</em>, <em>plot_type</em>, <em>time_interval=-1</em>, <em>num_of_pixels=-1</em>, <em>algorithm='LRU'</em>, <em>cache_params=None</em>, <em>cache_size=-1</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>plot heatmaps, currently supports the following heatmaps</p>
<ul class="simple">
<li>hit_ratio_start_time_end_time</li>
<li>hit_ratio_start_time_cache_size (python only)</li>
<li>avg_rd_start_time_end_time (python only)</li>
<li>cold_miss_count_start_time_end_time (python only)</li>
<li>rd_distribution</li>
<li>rd_distribution_CDF</li>
<li>future_rd_distribution</li>
<li>dist_distribution</li>
<li>reuse_time_distribution</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_mode</strong> – the type of time, can be “v” for virtual time, or “r” for real time</li>
<li><strong>plot_type</strong> – the name of plot types, see above for plot types</li>
<li><strong>time_interval</strong> – the time interval of one pixel</li>
<li><strong>num_of_pixels</strong> – if you don’t to use time_interval,
you can also specify how many pixels you want in one dimension,
note this feature is not well tested</li>
<li><strong>algorithm</strong> – what algorithm to use for plotting heatmap,
this is not required for distance related heatmap like rd_distribution</li>
<li><strong>cache_params</strong> – parameters passed to cache, some of the cache replacement algorithms require parameters,
for example LRU-K, SLRU</li>
<li><strong>cache_size</strong> – The size of cache, this is required only for <em>hit_ratio_start_time_end_time</em></li>
<li><strong>kwargs</strong> – other parameters for computation and plotting such as num_of_threads, figname</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">diff_heatmap</code><span class="sig-paren">(</span><em>time_mode</em>, <em>plot_type</em>, <em>algorithm1</em>, <em>time_interval=-1</em>, <em>num_of_pixels=-1</em>, <em>algorithm2='Optimal'</em>, <em>cache_params1=None</em>, <em>cache_params2=None</em>, <em>cache_size=-1</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Plot the differential heatmap between two algorithms by alg2 - alg1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cache_size</strong> – size of cache</li>
<li><strong>time_mode</strong> – time time_mode “v” for virutal time, “r” for real time</li>
<li><strong>plot_type</strong> – same as the name in heatmap function</li>
<li><strong>algorithm1</strong> – name of the first alg</li>
<li><strong>time_interval</strong> – same as in heatmap</li>
<li><strong>num_of_pixels</strong> – same as in heatmap</li>
<li><strong>algorithm2</strong> – name of the second algorithm</li>
<li><strong>cache_params1</strong> – parameters of the first algorithm</li>
<li><strong>cache_params2</strong> – parameters of the second algorithm</li>
<li><strong>kwargs</strong> – include num_of_threads</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">twoDPlot</code><span class="sig-paren">(</span><em>plot_type</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>an aggregate function for all two dimenional plots printing except hit ratio curve</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="28%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">plot type</th>
<th class="head">required parameters</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>cold_miss_count</td>
<td>time_mode, time_interval</td>
<td>cold miss count VS time</td>
</tr>
<tr class="row-odd"><td>cold_miss_ratio</td>
<td>time_mode, time_interval</td>
<td>coid miss ratio VS time</td>
</tr>
<tr class="row-even"><td>request_rate</td>
<td>time_mode, time_interval</td>
<td>num of requests VS time</td>
</tr>
<tr class="row-odd"><td>popularity</td>
<td>NA</td>
<td>Percentage of obj VS frequency</td>
</tr>
<tr class="row-even"><td>rd_popularity</td>
<td>NA</td>
<td>Num of req VS reuse distance</td>
</tr>
<tr class="row-odd"><td>rt_popularity</td>
<td>NA</td>
<td>Num of req VS reuse time</td>
</tr>
<tr class="row-even"><td>mapping</td>
<td>NA</td>
<td>mapping from original objID to sequential number</td>
</tr>
<tr class="row-odd"><td>interval_hit_ratio</td>
<td>cache_size</td>
<td>hit ratio of interval VS time</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>plot_type</strong> – type of the plot, see above</li>
<li><strong>kwargs</strong> – paramters related to plots, see twoDPlots module for detailed control over plots</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">plotHRCs</code><span class="sig-paren">(</span><em>algorithm_list</em>, <em>cache_params=()</em>, <em>cache_size=-1</em>, <em>bin_size=-1</em>, <em>auto_resize=True</em>, <em>figname='HRC.png'</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>this function provides hit ratio curve plotting</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>algorithm_list</strong> – a list of algorithm(s)</li>
<li><strong>cache_params</strong> – the corresponding cache params for the algorithms,
use None for algorithms that don’t require cache params,
if none of the alg requires cache params, you don’t need to set this</li>
<li><strong>cache_size</strong> – maximal size of cache, use -1 for max possible size</li>
<li><strong>bin_size</strong> – bin size for non-LRU profiling</li>
<li><strong>auto_resize</strong> – when using max possible size or specified cache size too large,
you will get a huge plateau at the end of hit ratio curve,
set auto_resize to True to cutoff most of the big plateau</li>
<li><strong>figname</strong> – name of figure</li>
<li><strong>kwargs</strong> – <p>options: block_unit_size, num_of_threads,
auto_resize_threshold, xlimit, ylimit, cache_unit_size</p>
<p>save_gradually - save a figure everytime computation for one algorithm finishes,</p>
<p>label - instead of using algorithm list as label, specify user-defined label</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">characterize</code><span class="sig-paren">(</span><em>characterize_type</em>, <em>cache_size=-1</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>use this function to obtain a series of plots about your trace, the type includes</p>
<ul class="simple">
<li>short - short run time, fewer plots with less accuracy</li>
<li>medium</li>
<li>long</li>
<li>all - most of the available plots with high accuracy, notice it can take <strong>LONG</strong> time on big trace</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>characterize_type</strong> – see above, options: short, medium, long, all</li>
<li><strong>cache_size</strong> – estimated cache size for the trace, if -1, PyMimircache will estimate the cache size</li>
<li><strong>kwargs</strong> – print_stat</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">trace stat string</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="profiler.html" title="API-profiler"
             >next</a> |</li>
        <li class="right" >
          <a href="../API.html" title="API"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PyMimircache v0.0.2.88</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../API.html" >API</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2017, Juncheng Yang.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>